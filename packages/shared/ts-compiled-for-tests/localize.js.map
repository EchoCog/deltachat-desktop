{
  "version": 3,
  "sources": ["../localize.ts"],
  "sourcesContent": ["import { getLogger } from './logger.js'\nimport { TranslationKey } from './translationKeyType.js'\nconst log = getLogger('localize')\n\nexport interface LocaleData {\n  locale: string\n  messages: {\n    [key: string]: {\n      [P in Intl.LDMLPluralRule]?: string\n    } & {\n      message?: string\n    }\n  }\n}\n\n// 'other' should exists for all languages (source?)\n// https://www.unicode.org/cldr/charts/43/supplemental/language_plural_rules.html\ntype getMessageOptions = { quantity?: 'other' | number }\n\nexport type getMessageFunction = (\n  key: TranslationKey,\n  substitutions?: string | string[],\n  raw_opts?: 'other' | getMessageOptions\n) => string\n\nexport function translate(\n  locale: string,\n  messages: LocaleData['messages']\n): getMessageFunction {\n  const localeBCP47 = locale.replace('_', '-')\n  let pluralRules: Intl.PluralRules\n  try {\n    pluralRules = new Intl.PluralRules(localeBCP47)\n  } catch (err) {\n    // Ideally we'd want a build-time check for this.\n    // But let's not crash for this silly reason and apply the rules that apply\n    // for many languages (see https://www.unicode.org/cldr/charts/43/supplemental/language_plural_rules.html#Cardinal-Integer)\n    // Although keep in mind that English only has 'one' and 'other'\n    // plural categorues, but some languages, such as Korean,\n    // do not have 'one': only 'other'.\n    // Before you ask, yes, _all_ languages have 'other' (source?)\n    log.errorWithoutStackTrace(err)\n\n    pluralRules = new Intl.PluralRules('en')\n  }\n\n  function getMessage(\n    key: TranslationKey,\n    substitutions?: string | string[],\n    raw_opts?: 'other' | getMessageOptions\n  ) {\n    const translationKey = key as string\n    let opts: getMessageOptions = {}\n    if (typeof raw_opts === 'string') opts = { quantity: raw_opts }\n    else opts = Object.assign({}, raw_opts)\n\n    const entry = messages[translationKey]\n\n    if (!entry) {\n      log.error(`Missing translation for key '${translationKey}'`)\n      return translationKey\n    }\n\n    let message: string | undefined = entry.message\n    if (typeof opts.quantity !== 'undefined') {\n      if (typeof opts.quantity === 'string') {\n        message = entry[opts.quantity]\n      } else if (typeof opts.quantity === 'number') {\n        message =\n          entry[opts.quantity as unknown as keyof LocaleData['messages'][0]] ||\n          // TODO fix: simply using `pluralRules.select()` to index\n          // into the object is not quite right,\n          // because the string could be untranslated, and it'd fall back to\n          // English, with only 'one' and 'other' plural categories,\n          // in which case we must apply the English\n          // plural rules instead of the current locale's rules.\n          //\n          // Currently this is behaves incorrectly e.g. for untranslated\n          // Indonesian (id), which only has the 'other' plural category,\n          // so even when we have to use 'one' for English, we'd use 'other'.\n          //\n          // But currently we don't have a way to distinguish between translated\n          // and untranslated strings in this code.\n          // See https://github.com/deltachat/deltachat-desktop/blob/b342a1d47b505e68caaec71f79c381c3f304405a/src/main/load-translations.ts#L44-L64\n          entry[pluralRules.select(opts.quantity)] ||\n          // This also catches the case where we failed to construct\n          // `Intl.PluralRules` for the currentl locale, and fall back to\n          // English (see `try catch` above).\n          entry['other']\n      } else {\n        message = undefined\n      }\n      if (typeof message === 'undefined') {\n        log.error(\n          `Missing quantity '${opts.quantity}' for key '${translationKey}'`\n        )\n        return `${translationKey}:${opts.quantity}`\n      }\n    }\n\n    if (typeof message === 'undefined') {\n      log.error(\n        `Missing 'message' for key '${translationKey}', maybe you need to specify quantity`\n      )\n      return `${translationKey}:?`\n    }\n\n    if (substitutions) {\n      if (!Array.isArray(substitutions)) {\n        substitutions = [substitutions]\n      }\n\n      let counter = -1\n      return message.replace(/(?:%\\d\\$[\\w\\d])|(?:%[\\w\\d])/g, f => {\n        counter++\n        if (f.length > 2) {\n          const index = Number.parseInt(f[1]) - 1\n          if (\n            substitutions === undefined ||\n            typeof substitutions[index] === 'undefined'\n          ) {\n            log.error(`Missing ${index} argument for key %c'${translationKey}'`)\n            return ''\n          }\n          return substitutions[index].toString()\n        }\n        // TODO find out if there is a case with multiple substitutionsand quantity\n        if (\n          substitutions === undefined ||\n          typeof substitutions?.[counter] === 'undefined'\n        ) {\n          log.error(`Missing ${0} argument for key %c'${translationKey}'`)\n          return ''\n        }\n        return substitutions[counter].toString()\n      })\n    }\n\n    return message\n  }\n\n  return getMessage\n}\n"],
  "mappings": ";AAAA,SAAS,iBAAiB;AAE1B,MAAM,MAAM,UAAU,UAAU;AAuBzB,gBAAS,UACd,QACA,UACoB;AACpB,QAAM,cAAc,OAAO,QAAQ,KAAK,GAAG;AAC3C,MAAI;AACJ,MAAI;AACF,kBAAc,IAAI,KAAK,YAAY,WAAW;AAAA,EAChD,SAAS,KAAK;AAQZ,QAAI,uBAAuB,GAAG;AAE9B,kBAAc,IAAI,KAAK,YAAY,IAAI;AAAA,EACzC;AAEA,WAAS,WACP,KACA,eACA,UACA;AACA,UAAM,iBAAiB;AACvB,QAAI,OAA0B,CAAC;AAC/B,QAAI,OAAO,aAAa,SAAU,QAAO,EAAE,UAAU,SAAS;AAAA,QACzD,QAAO,OAAO,OAAO,CAAC,GAAG,QAAQ;AAEtC,UAAM,QAAQ,SAAS,cAAc;AAErC,QAAI,CAAC,OAAO;AACV,UAAI,MAAM,gCAAgC,cAAc,GAAG;AAC3D,aAAO;AAAA,IACT;AAEA,QAAI,UAA8B,MAAM;AACxC,QAAI,OAAO,KAAK,aAAa,aAAa;AACxC,UAAI,OAAO,KAAK,aAAa,UAAU;AACrC,kBAAU,MAAM,KAAK,QAAQ;AAAA,MAC/B,WAAW,OAAO,KAAK,aAAa,UAAU;AAC5C,kBACE,MAAM,KAAK,QAAsD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,QAejE,MAAM,YAAY,OAAO,KAAK,QAAQ,CAAC;AAAA;AAAA;AAAA,QAIvC,MAAM,OAAO;AAAA,MACjB,OAAO;AACL,kBAAU;AAAA,MACZ;AACA,UAAI,OAAO,YAAY,aAAa;AAClC,YAAI;AAAA,UACF,qBAAqB,KAAK,QAAQ,cAAc,cAAc;AAAA,QAChE;AACA,eAAO,GAAG,cAAc,IAAI,KAAK,QAAQ;AAAA,MAC3C;AAAA,IACF;AAEA,QAAI,OAAO,YAAY,aAAa;AAClC,UAAI;AAAA,QACF,8BAA8B,cAAc;AAAA,MAC9C;AACA,aAAO,GAAG,cAAc;AAAA,IAC1B;AAEA,QAAI,eAAe;AACjB,UAAI,CAAC,MAAM,QAAQ,aAAa,GAAG;AACjC,wBAAgB,CAAC,aAAa;AAAA,MAChC;AAEA,UAAI,UAAU;AACd,aAAO,QAAQ,QAAQ,gCAAgC,OAAK;AAC1D;AACA,YAAI,EAAE,SAAS,GAAG;AAChB,gBAAM,QAAQ,OAAO,SAAS,EAAE,CAAC,CAAC,IAAI;AACtC,cACE,kBAAkB,UAClB,OAAO,cAAc,KAAK,MAAM,aAChC;AACA,gBAAI,MAAM,WAAW,KAAK,wBAAwB,cAAc,GAAG;AACnE,mBAAO;AAAA,UACT;AACA,iBAAO,cAAc,KAAK,EAAE,SAAS;AAAA,QACvC;AAEA,YACE,kBAAkB,UAClB,OAAO,gBAAgB,OAAO,MAAM,aACpC;AACA,cAAI,MAAM,WAAW,CAAC,wBAAwB,cAAc,GAAG;AAC/D,iBAAO;AAAA,QACT;AACA,eAAO,cAAc,OAAO,EAAE,SAAS;AAAA,MACzC,CAAC;AAAA,IACH;AAEA,WAAO;AAAA,EACT;AAEA,SAAO;AACT;",
  "names": []
}
