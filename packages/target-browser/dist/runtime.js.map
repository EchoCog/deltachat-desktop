{
  "version": 3,
  "sources": ["../../../node_modules/.pnpm/isomorphic-ws@4.0.1_ws@8.18.0/node_modules/isomorphic-ws/browser.js", "../../../node_modules/.pnpm/@deltachat+tiny-emitter@3.0.0/node_modules/@deltachat/tiny-emitter/index.js", "../../../node_modules/.pnpm/@deltachat+jsonrpc-client@1.159.4_ws@8.18.0/node_modules/@deltachat/jsonrpc-client/generated/client.ts", "../../../node_modules/.pnpm/yerpc@0.6.2/node_modules/yerpc/index.ts", "../../../node_modules/.pnpm/yerpc@0.6.2/node_modules/yerpc/util/emitter.ts", "../../../node_modules/.pnpm/yerpc@0.6.2/node_modules/yerpc/client.ts", "../../../node_modules/.pnpm/yerpc@0.6.2/node_modules/yerpc/websocket.ts", "../../../node_modules/.pnpm/@deltachat+jsonrpc-client@1.159.4_ws@8.18.0/node_modules/@deltachat/jsonrpc-client/src/client.ts", "../../../node_modules/.pnpm/@deltachat+jsonrpc-client@1.159.4_ws@8.18.0/node_modules/@deltachat/jsonrpc-client/generated/constants.ts", "../../shared/themes.ts", "../runtime-browser/runtime.ts"],
  "sourcesContent": ["// https://github.com/maxogden/websocket-stream/blob/48dc3ddf943e5ada668c31ccd94e9186f02fafbd/ws-fallback.js\n\nvar ws = null\n\nif (typeof WebSocket !== 'undefined') {\n  ws = WebSocket\n} else if (typeof MozWebSocket !== 'undefined') {\n  ws = MozWebSocket\n} else if (typeof global !== 'undefined') {\n  ws = global.WebSocket || global.MozWebSocket\n} else if (typeof window !== 'undefined') {\n  ws = window.WebSocket || window.MozWebSocket\n} else if (typeof self !== 'undefined') {\n  ws = self.WebSocket || self.MozWebSocket\n}\n\nmodule.exports = ws\n", "function E () {\n  // Keep this empty so it's easier to inherit from\n  // (via https://github.com/lipsmack from https://github.com/scottcorgan/tiny-emitter/issues/3)\n}\n\nE.prototype = {\n  on: function (name, callback, ctx) {\n    var e = this.e || (this.e = {});\n\n    (e[name] || (e[name] = [])).push({\n      fn: callback,\n      ctx: ctx\n    });\n\n    return this;\n  },\n\n  once: function (name, callback, ctx) {\n    var self = this;\n    function listener () {\n      self.off(name, listener);\n      callback.apply(ctx, arguments);\n    };\n\n    listener._ = callback\n    return this.on(name, listener, ctx);\n  },\n\n  emit: function (name) {\n    var data = [].slice.call(arguments, 1);\n    var evtArr = ((this.e || (this.e = {}))[name] || []).slice();\n    var i = 0;\n    var len = evtArr.length;\n\n    for (i; i < len; i++) {\n      try {\n        evtArr[i].fn.apply(evtArr[i].ctx, data);\n      } catch (error) {\n        console.error(\"event listener for event '\"+String(name)+\"' threw an error:\", error, evtArr[i].fn);\n      }\n    }\n\n    return this;\n  },\n\n  off: function (name, callback) {\n    var e = this.e || (this.e = {});\n    var evts = e[name];\n    var liveEvents = [];\n\n    if (evts && callback) {\n      for (var i = 0, len = evts.length; i < len; i++) {\n        if (evts[i].fn !== callback && evts[i].fn._ !== callback)\n          liveEvents.push(evts[i]);\n      }\n    }\n\n    // Remove event from queue to prevent memory leak\n    // Suggested by https://github.com/lazd\n    // Ref: https://github.com/scottcorgan/tiny-emitter/commit/c6ebfaa9bc973b33d110a84a307742b7cf94c953#commitcomment-5024910\n\n    (liveEvents.length)\n      ? e[name] = liveEvents\n      : delete e[name];\n\n    return this;\n  }\n};\n\nmodule.exports = E;\nmodule.exports.TinyEmitter = E;\n", "// AUTO-GENERATED by yerpc-derive\n\nimport * as T from \"./types.js\"\nimport * as RPC from \"./jsonrpc.js\"\n\ntype RequestMethod = (method: string, params?: RPC.Params) => Promise<unknown>;\ntype NotificationMethod = (method: string, params?: RPC.Params) => void;\n\ninterface Transport {\n  request: RequestMethod,\n  notification: NotificationMethod\n}\n\nexport class RawClient {\n  constructor(private _transport: Transport) {}\n\n  /**\n   * Test function.\n   */\n  public sleep(delay: T.F64): Promise<void> {\n    return (this._transport.request('sleep', [delay] as RPC.Params)) as Promise<void>;\n  }\n\n  /**\n   * Checks if an email address is valid.\n   */\n  public checkEmailValidity(email: string): Promise<boolean> {\n    return (this._transport.request('check_email_validity', [email] as RPC.Params)) as Promise<boolean>;\n  }\n\n  /**\n   * Returns general system info.\n   */\n  public getSystemInfo(): Promise<Record<string, string>> {\n    return (this._transport.request('get_system_info', [] as RPC.Params)) as Promise<Record<string, string>>;\n  }\n\n  /**\n   * Get the next event.\n   */\n  public getNextEvent(): Promise<T.Event> {\n    return (this._transport.request('get_next_event', [] as RPC.Params)) as Promise<T.Event>;\n  }\n\n\n  public addAccount(): Promise<T.U32> {\n    return (this._transport.request('add_account', [] as RPC.Params)) as Promise<T.U32>;\n  }\n\n  /**\n   * Imports/migrated an existing account from a database path into this account manager.\n   * Returns the ID of new account.\n   */\n  public migrateAccount(pathToDb: string): Promise<T.U32> {\n    return (this._transport.request('migrate_account', [pathToDb] as RPC.Params)) as Promise<T.U32>;\n  }\n\n\n  public removeAccount(accountId: T.U32): Promise<null> {\n    return (this._transport.request('remove_account', [accountId] as RPC.Params)) as Promise<null>;\n  }\n\n\n  public getAllAccountIds(): Promise<(T.U32)[]> {\n    return (this._transport.request('get_all_account_ids', [] as RPC.Params)) as Promise<(T.U32)[]>;\n  }\n\n  /**\n   * Select account in account manager, this saves the last used account to accounts.toml\n   */\n  public selectAccount(id: T.U32): Promise<null> {\n    return (this._transport.request('select_account', [id] as RPC.Params)) as Promise<null>;\n  }\n\n  /**\n   * Get the selected account from the account manager (on startup it is read from accounts.toml)\n   */\n  public getSelectedAccountId(): Promise<(T.U32 | null)> {\n    return (this._transport.request('get_selected_account_id', [] as RPC.Params)) as Promise<(T.U32 | null)>;\n  }\n\n  /**\n   * Get a list of all configured accounts.\n   */\n  public getAllAccounts(): Promise<(T.Account)[]> {\n    return (this._transport.request('get_all_accounts', [] as RPC.Params)) as Promise<(T.Account)[]>;\n  }\n\n  /**\n   * Starts background tasks for all accounts.\n   */\n  public startIoForAllAccounts(): Promise<null> {\n    return (this._transport.request('start_io_for_all_accounts', [] as RPC.Params)) as Promise<null>;\n  }\n\n  /**\n   * Stops background tasks for all accounts.\n   */\n  public stopIoForAllAccounts(): Promise<null> {\n    return (this._transport.request('stop_io_for_all_accounts', [] as RPC.Params)) as Promise<null>;\n  }\n\n  /**\n   * Performs a background fetch for all accounts in parallel with a timeout.\n   *\n   * The `AccountsBackgroundFetchDone` event is emitted at the end even in case of timeout.\n   * Process all events until you get this one and you can safely return to the background\n   * without forgetting to create notifications caused by timing race conditions.\n   */\n  public accountsBackgroundFetch(timeoutInSeconds: T.F64): Promise<null> {\n    return (this._transport.request('accounts_background_fetch', [timeoutInSeconds] as RPC.Params)) as Promise<null>;\n  }\n\n  /**\n   * Starts background tasks for a single account.\n   */\n  public startIo(accountId: T.U32): Promise<null> {\n    return (this._transport.request('start_io', [accountId] as RPC.Params)) as Promise<null>;\n  }\n\n  /**\n   * Stops background tasks for a single account.\n   */\n  public stopIo(accountId: T.U32): Promise<null> {\n    return (this._transport.request('stop_io', [accountId] as RPC.Params)) as Promise<null>;\n  }\n\n  /**\n   * Get top-level info for an account.\n   */\n  public getAccountInfo(accountId: T.U32): Promise<T.Account> {\n    return (this._transport.request('get_account_info', [accountId] as RPC.Params)) as Promise<T.Account>;\n  }\n\n  /**\n   * Get the combined filesize of an account in bytes\n   */\n  public getAccountFileSize(accountId: T.U32): Promise<T.U64> {\n    return (this._transport.request('get_account_file_size', [accountId] as RPC.Params)) as Promise<T.U64>;\n  }\n\n  /**\n   * Returns provider for the given domain.\n   *\n   * This function looks up domain in offline database.\n   *\n   * For compatibility, email address can be passed to this function\n   * instead of the domain.\n   */\n  public getProviderInfo(accountId: T.U32, email: string): Promise<(T.ProviderInfo | null)> {\n    return (this._transport.request('get_provider_info', [accountId, email] as RPC.Params)) as Promise<(T.ProviderInfo | null)>;\n  }\n\n  /**\n   * Checks if the context is already configured.\n   */\n  public isConfigured(accountId: T.U32): Promise<boolean> {\n    return (this._transport.request('is_configured', [accountId] as RPC.Params)) as Promise<boolean>;\n  }\n\n  /**\n   * Get system info for an account.\n   */\n  public getInfo(accountId: T.U32): Promise<Record<string, string>> {\n    return (this._transport.request('get_info', [accountId] as RPC.Params)) as Promise<Record<string, string>>;\n  }\n\n  /**\n   * Get the blob dir.\n   */\n  public getBlobDir(accountId: T.U32): Promise<(string | null)> {\n    return (this._transport.request('get_blob_dir', [accountId] as RPC.Params)) as Promise<(string | null)>;\n  }\n\n  /**\n   * Copy file to blob dir.\n   */\n  public copyToBlobDir(accountId: T.U32, path: string): Promise<string> {\n    return (this._transport.request('copy_to_blob_dir', [accountId, path] as RPC.Params)) as Promise<string>;\n  }\n\n\n  public draftSelfReport(accountId: T.U32): Promise<T.U32> {\n    return (this._transport.request('draft_self_report', [accountId] as RPC.Params)) as Promise<T.U32>;\n  }\n\n  /**\n   * Sets the given configuration key.\n   */\n  public setConfig(accountId: T.U32, key: string, value: (string | null)): Promise<null> {\n    return (this._transport.request('set_config', [accountId, key, value] as RPC.Params)) as Promise<null>;\n  }\n\n  /**\n   * Updates a batch of configuration values.\n   */\n  public batchSetConfig(accountId: T.U32, config: Record<string, (string | null)>): Promise<null> {\n    return (this._transport.request('batch_set_config', [accountId, config] as RPC.Params)) as Promise<null>;\n  }\n\n  /**\n   * Set configuration values from a QR code. (technically from the URI that is stored in the qrcode)\n   * Before this function is called, `checkQr()` should confirm the type of the\n   * QR code is `account` or `webrtcInstance`.\n   *\n   * Internally, the function will call dc_set_config() with the appropriate keys,\n   */\n  public setConfigFromQr(accountId: T.U32, qrContent: string): Promise<null> {\n    return (this._transport.request('set_config_from_qr', [accountId, qrContent] as RPC.Params)) as Promise<null>;\n  }\n\n\n  public checkQr(accountId: T.U32, qrContent: string): Promise<T.Qr> {\n    return (this._transport.request('check_qr', [accountId, qrContent] as RPC.Params)) as Promise<T.Qr>;\n  }\n\n  /**\n   * Returns configuration value for the given key.\n   */\n  public getConfig(accountId: T.U32, key: string): Promise<(string | null)> {\n    return (this._transport.request('get_config', [accountId, key] as RPC.Params)) as Promise<(string | null)>;\n  }\n\n\n  public batchGetConfig(accountId: T.U32, keys: (string)[]): Promise<Record<string, (string | null)>> {\n    return (this._transport.request('batch_get_config', [accountId, keys] as RPC.Params)) as Promise<Record<string, (string | null)>>;\n  }\n\n\n  public setStockStrings(strings: Record<T.U32, string>): Promise<null> {\n    return (this._transport.request('set_stock_strings', [strings] as RPC.Params)) as Promise<null>;\n  }\n\n  /**\n   * Configures this account with the currently set parameters.\n   * Setup the credential config before calling this.\n   *\n   * Deprecated as of 2025-02; use `add_transport_from_qr()`\n   * or `add_or_update_transport()` instead.\n   */\n  public configure(accountId: T.U32): Promise<null> {\n    return (this._transport.request('configure', [accountId] as RPC.Params)) as Promise<null>;\n  }\n\n  /**\n   * Configures a new email account using the provided parameters\n   * and adds it as a transport.\n   *\n   * If the email address is the same as an existing transport,\n   * then this existing account will be reconfigured instead of a new one being added.\n   *\n   * This function stops and starts IO as needed.\n   *\n   * Usually it will be enough to only set `addr` and `password`,\n   * and all the other settings will be autoconfigured.\n   *\n   * During configuration, ConfigureProgress events are emitted;\n   * they indicate a successful configuration as well as errors\n   * and may be used to create a progress bar.\n   * This function will return after configuration is finished.\n   *\n   * If configuration is successful,\n   * the working server parameters will be saved\n   * and used for connecting to the server.\n   * The parameters entered by the user will be saved separately\n   * so that they can be prefilled when the user opens the server-configuration screen again.\n   *\n   * See also:\n   * - [Self::is_configured()] to check whether there is\n   *   at least one working transport.\n   * - [Self::add_transport_from_qr()] to add a transport\n   *   from a server encoded in a QR code.\n   * - [Self::list_transports()] to get a list of all configured transports.\n   * - [Self::delete_transport()] to remove a transport.\n   */\n  public addOrUpdateTransport(accountId: T.U32, param: T.EnteredLoginParam): Promise<null> {\n    return (this._transport.request('add_or_update_transport', [accountId, param] as RPC.Params)) as Promise<null>;\n  }\n\n  /**\n   * Deprecated 2025-04. Alias for [Self::add_or_update_transport()].\n   */\n  public addTransport(accountId: T.U32, param: T.EnteredLoginParam): Promise<null> {\n    return (this._transport.request('add_transport', [accountId, param] as RPC.Params)) as Promise<null>;\n  }\n\n  /**\n   * Adds a new email account as a transport\n   * using the server encoded in the QR code.\n   * See [Self::add_or_update_transport].\n   */\n  public addTransportFromQr(accountId: T.U32, qr: string): Promise<null> {\n    return (this._transport.request('add_transport_from_qr', [accountId, qr] as RPC.Params)) as Promise<null>;\n  }\n\n  /**\n   * Returns the list of all email accounts that are used as a transport in the current profile.\n   * Use [Self::add_or_update_transport()] to add or change a transport\n   * and [Self::delete_transport()] to delete a transport.\n   */\n  public listTransports(accountId: T.U32): Promise<(T.EnteredLoginParam)[]> {\n    return (this._transport.request('list_transports', [accountId] as RPC.Params)) as Promise<(T.EnteredLoginParam)[]>;\n  }\n\n  /**\n   * Removes the transport with the specified email address\n   * (i.e. [EnteredLoginParam::addr]).\n   */\n  public deleteTransport(accountId: T.U32, addr: string): Promise<null> {\n    return (this._transport.request('delete_transport', [accountId, addr] as RPC.Params)) as Promise<null>;\n  }\n\n  /**\n   * Signal an ongoing process to stop.\n   */\n  public stopOngoingProcess(accountId: T.U32): Promise<null> {\n    return (this._transport.request('stop_ongoing_process', [accountId] as RPC.Params)) as Promise<null>;\n  }\n\n\n  public exportSelfKeys(accountId: T.U32, path: string, passphrase: (string | null)): Promise<null> {\n    return (this._transport.request('export_self_keys', [accountId, path, passphrase] as RPC.Params)) as Promise<null>;\n  }\n\n\n  public importSelfKeys(accountId: T.U32, path: string, passphrase: (string | null)): Promise<null> {\n    return (this._transport.request('import_self_keys', [accountId, path, passphrase] as RPC.Params)) as Promise<null>;\n  }\n\n  /**\n   * Returns the message IDs of all _fresh_ messages of any chat.\n   * Typically used for implementing notification summaries\n   * or badge counters e.g. on the app icon.\n   * The list is already sorted and starts with the most recent fresh message.\n   *\n   * Messages belonging to muted chats or to the contact requests are not returned;\n   * these messages should not be notified\n   * and also badge counters should not include these messages.\n   *\n   * To get the number of fresh messages for a single chat, muted or not,\n   * use `get_fresh_msg_cnt()`.\n   */\n  public getFreshMsgs(accountId: T.U32): Promise<(T.U32)[]> {\n    return (this._transport.request('get_fresh_msgs', [accountId] as RPC.Params)) as Promise<(T.U32)[]>;\n  }\n\n  /**\n   * Get the number of _fresh_ messages in a chat.\n   * Typically used to implement a badge with a number in the chatlist.\n   *\n   * If the specified chat is muted,\n   * the UI should show the badge counter \"less obtrusive\",\n   * e.g. using \"gray\" instead of \"red\" color.\n   */\n  public getFreshMsgCnt(accountId: T.U32, chatId: T.U32): Promise<T.Usize> {\n    return (this._transport.request('get_fresh_msg_cnt', [accountId, chatId] as RPC.Params)) as Promise<T.Usize>;\n  }\n\n  /**\n   * Gets messages to be processed by the bot and returns their IDs.\n   *\n   * Only messages with database ID higher than `last_msg_id` config value\n   * are returned. After processing the messages, the bot should\n   * update `last_msg_id` by calling [`markseen_msgs`]\n   * or manually updating the value to avoid getting already\n   * processed messages.\n   *\n   * [`markseen_msgs`]: Self::markseen_msgs\n   */\n  public getNextMsgs(accountId: T.U32): Promise<(T.U32)[]> {\n    return (this._transport.request('get_next_msgs', [accountId] as RPC.Params)) as Promise<(T.U32)[]>;\n  }\n\n  /**\n   * Waits for messages to be processed by the bot and returns their IDs.\n   *\n   * This function is similar to [`get_next_msgs`],\n   * but waits for internal new message notification before returning.\n   * New message notification is sent when new message is added to the database,\n   * on initialization, when I/O is started and when I/O is stopped.\n   * This allows bots to use `wait_next_msgs` in a loop to process\n   * old messages after initialization and during the bot runtime.\n   * To shutdown the bot, stopping I/O can be used to interrupt\n   * pending or next `wait_next_msgs` call.\n   *\n   * [`get_next_msgs`]: Self::get_next_msgs\n   */\n  public waitNextMsgs(accountId: T.U32): Promise<(T.U32)[]> {\n    return (this._transport.request('wait_next_msgs', [accountId] as RPC.Params)) as Promise<(T.U32)[]>;\n  }\n\n  /**\n   * Estimate the number of messages that will be deleted\n   * by the set_config()-options `delete_device_after` or `delete_server_after`.\n   * This is typically used to show the estimated impact to the user\n   * before actually enabling deletion of old messages.\n   */\n  public estimateAutoDeletionCount(accountId: T.U32, fromServer: boolean, seconds: T.I64): Promise<T.Usize> {\n    return (this._transport.request('estimate_auto_deletion_count', [accountId, fromServer, seconds] as RPC.Params)) as Promise<T.Usize>;\n  }\n\n\n  public initiateAutocryptKeyTransfer(accountId: T.U32): Promise<string> {\n    return (this._transport.request('initiate_autocrypt_key_transfer', [accountId] as RPC.Params)) as Promise<string>;\n  }\n\n\n  public continueAutocryptKeyTransfer(accountId: T.U32, messageId: T.U32, setupCode: string): Promise<null> {\n    return (this._transport.request('continue_autocrypt_key_transfer', [accountId, messageId, setupCode] as RPC.Params)) as Promise<null>;\n  }\n\n\n  public getChatlistEntries(accountId: T.U32, listFlags: (T.U32 | null), queryString: (string | null), queryContactId: (T.U32 | null)): Promise<(T.U32)[]> {\n    return (this._transport.request('get_chatlist_entries', [accountId, listFlags, queryString, queryContactId] as RPC.Params)) as Promise<(T.U32)[]>;\n  }\n\n  /**\n   * Returns chats similar to the given one.\n   *\n   * Experimental API, subject to change without notice.\n   */\n  public getSimilarChatIds(accountId: T.U32, chatId: T.U32): Promise<(T.U32)[]> {\n    return (this._transport.request('get_similar_chat_ids', [accountId, chatId] as RPC.Params)) as Promise<(T.U32)[]>;\n  }\n\n\n  public getChatlistItemsByEntries(accountId: T.U32, entries: (T.U32)[]): Promise<Record<T.U32, T.ChatListItemFetchResult>> {\n    return (this._transport.request('get_chatlist_items_by_entries', [accountId, entries] as RPC.Params)) as Promise<Record<T.U32, T.ChatListItemFetchResult>>;\n  }\n\n\n  public getFullChatById(accountId: T.U32, chatId: T.U32): Promise<T.FullChat> {\n    return (this._transport.request('get_full_chat_by_id', [accountId, chatId] as RPC.Params)) as Promise<T.FullChat>;\n  }\n\n  /**\n   * get basic info about a chat,\n   * use chatlist_get_full_chat_by_id() instead if you need more information\n   */\n  public getBasicChatInfo(accountId: T.U32, chatId: T.U32): Promise<T.BasicChat> {\n    return (this._transport.request('get_basic_chat_info', [accountId, chatId] as RPC.Params)) as Promise<T.BasicChat>;\n  }\n\n\n  public acceptChat(accountId: T.U32, chatId: T.U32): Promise<null> {\n    return (this._transport.request('accept_chat', [accountId, chatId] as RPC.Params)) as Promise<null>;\n  }\n\n\n  public blockChat(accountId: T.U32, chatId: T.U32): Promise<null> {\n    return (this._transport.request('block_chat', [accountId, chatId] as RPC.Params)) as Promise<null>;\n  }\n\n  /**\n   * Delete a chat.\n   *\n   * Messages are deleted from the device and the chat database entry is deleted.\n   * After that, the event #DC_EVENT_MSGS_CHANGED is posted.\n   *\n   * Things that are _not done_ implicitly:\n   *\n   * - Messages are **not deleted from the server**.\n   * - The chat or the contact is **not blocked**, so new messages from the user/the group may appear as a contact request\n   *   and the user may create the chat again.\n   * - **Groups are not left** - this would\n   *   be unexpected as (1) deleting a normal chat also does not prevent new mails\n   *   from arriving, (2) leaving a group requires sending a message to\n   *   all group members - especially for groups not used for a longer time, this is\n   *   really unexpected when deletion results in contacting all members again,\n   *   (3) only leaving groups is also a valid usecase.\n   *\n   * To leave a chat explicitly, use leave_group()\n   */\n  public deleteChat(accountId: T.U32, chatId: T.U32): Promise<null> {\n    return (this._transport.request('delete_chat', [accountId, chatId] as RPC.Params)) as Promise<null>;\n  }\n\n  /**\n   * Get encryption info for a chat.\n   * Get a multi-line encryption info, containing encryption preferences of all members.\n   * Can be used to find out why messages sent to group are not encrypted.\n   *\n   * returns Multi-line text\n   */\n  public getChatEncryptionInfo(accountId: T.U32, chatId: T.U32): Promise<string> {\n    return (this._transport.request('get_chat_encryption_info', [accountId, chatId] as RPC.Params)) as Promise<string>;\n  }\n\n  /**\n   * Get QR code text that will offer a [SecureJoin](https://securejoin.delta.chat/) invitation.\n   *\n   * If `chat_id` is a group chat ID, SecureJoin QR code for the group is returned.\n   * If `chat_id` is unset, setup contact QR code is returned.\n   */\n  public getChatSecurejoinQrCode(accountId: T.U32, chatId: (T.U32 | null)): Promise<string> {\n    return (this._transport.request('get_chat_securejoin_qr_code', [accountId, chatId] as RPC.Params)) as Promise<string>;\n  }\n\n  /**\n   * Get QR code (text and SVG) that will offer a Setup-Contact or Verified-Group invitation.\n   * The QR code is compatible to the OPENPGP4FPR format\n   * so that a basic fingerprint comparison also works e.g. with OpenKeychain.\n   *\n   * The scanning device will pass the scanned content to `checkQr()` then;\n   * if `checkQr()` returns `askVerifyContact` or `askVerifyGroup`\n   * an out-of-band-verification can be joined using `secure_join()`\n   *\n   * chat_id: If set to a group-chat-id,\n   *     the Verified-Group-Invite protocol is offered in the QR code;\n   *     works for protected groups as well as for normal groups.\n   *     If not set, the Setup-Contact protocol is offered in the QR code.\n   *     See https://securejoin.delta.chat/ for details about both protocols.\n   *\n   * return format: `[code, svg]`\n   */\n  public getChatSecurejoinQrCodeSvg(accountId: T.U32, chatId: (T.U32 | null)): Promise<[string, string]> {\n    return (this._transport.request('get_chat_securejoin_qr_code_svg', [accountId, chatId] as RPC.Params)) as Promise<[string, string]>;\n  }\n\n  /**\n   * Continue a Setup-Contact or Verified-Group-Invite protocol\n   * started on another device with `get_chat_securejoin_qr_code_svg()`.\n   * This function is typically called when `check_qr()` returns\n   * type=AskVerifyContact or type=AskVerifyGroup.\n   *\n   * The function returns immediately and the handshake runs in background,\n   * sending and receiving several messages.\n   * During the handshake, info messages are added to the chat,\n   * showing progress, success or errors.\n   *\n   * Subsequent calls of `secure_join()` will abort previous, unfinished handshakes.\n   *\n   * See https://securejoin.delta.chat/ for details about both protocols.\n   *\n   * **qr**: The text of the scanned QR code. Typically, the same string as given\n   *     to `check_qr()`.\n   *\n   * **returns**: The chat ID of the joined chat, the UI may redirect to the this chat.\n   *         A returned chat ID does not guarantee that the chat is protected or the belonging contact is verified.\n   *\n   */\n  public secureJoin(accountId: T.U32, qr: string): Promise<T.U32> {\n    return (this._transport.request('secure_join', [accountId, qr] as RPC.Params)) as Promise<T.U32>;\n  }\n\n\n  public leaveGroup(accountId: T.U32, chatId: T.U32): Promise<null> {\n    return (this._transport.request('leave_group', [accountId, chatId] as RPC.Params)) as Promise<null>;\n  }\n\n  /**\n   * Remove a member from a group.\n   *\n   * If the group is already _promoted_ (any message was sent to the group),\n   * all group members are informed by a special status message that is sent automatically by this function.\n   *\n   * Sends out #DC_EVENT_CHAT_MODIFIED and #DC_EVENT_MSGS_CHANGED if a status message was sent.\n   */\n  public removeContactFromChat(accountId: T.U32, chatId: T.U32, contactId: T.U32): Promise<null> {\n    return (this._transport.request('remove_contact_from_chat', [accountId, chatId, contactId] as RPC.Params)) as Promise<null>;\n  }\n\n  /**\n   * Add a member to a group.\n   *\n   * If the group is already _promoted_ (any message was sent to the group),\n   * all group members are informed by a special status message that is sent automatically by this function.\n   *\n   * If the group has group protection enabled, only verified contacts can be added to the group.\n   *\n   * Sends out #DC_EVENT_CHAT_MODIFIED and #DC_EVENT_MSGS_CHANGED if a status message was sent.\n   */\n  public addContactToChat(accountId: T.U32, chatId: T.U32, contactId: T.U32): Promise<null> {\n    return (this._transport.request('add_contact_to_chat', [accountId, chatId, contactId] as RPC.Params)) as Promise<null>;\n  }\n\n  /**\n   * Get the contact IDs belonging to a chat.\n   *\n   * - for normal chats, the function always returns exactly one contact,\n   *   DC_CONTACT_ID_SELF is returned only for SELF-chats.\n   *\n   * - for group chats all members are returned, DC_CONTACT_ID_SELF is returned\n   *   explicitly as it may happen that oneself gets removed from a still existing\n   *   group\n   *\n   * - for broadcasts, all recipients are returned, DC_CONTACT_ID_SELF is not included\n   *\n   * - for mailing lists, the behavior is not documented currently, we will decide on that later.\n   *   for now, the UI should not show the list for mailing lists.\n   *   (we do not know all members and there is not always a global mailing list address,\n   *   so we could return only SELF or the known members; this is not decided yet)\n   */\n  public getChatContacts(accountId: T.U32, chatId: T.U32): Promise<(T.U32)[]> {\n    return (this._transport.request('get_chat_contacts', [accountId, chatId] as RPC.Params)) as Promise<(T.U32)[]>;\n  }\n\n  /**\n   * Returns contact IDs of the past chat members.\n   */\n  public getPastChatContacts(accountId: T.U32, chatId: T.U32): Promise<(T.U32)[]> {\n    return (this._transport.request('get_past_chat_contacts', [accountId, chatId] as RPC.Params)) as Promise<(T.U32)[]>;\n  }\n\n  /**\n   * Create a new group chat.\n   *\n   * After creation,\n   * the group has one member with the ID DC_CONTACT_ID_SELF\n   * and is in _unpromoted_ state.\n   * This means, you can add or remove members, change the name,\n   * the group image and so on without messages being sent to all group members.\n   *\n   * This changes as soon as the first message is sent to the group members\n   * and the group becomes _promoted_.\n   * After that, all changes are synced with all group members\n   * by sending status message.\n   *\n   * To check, if a chat is still unpromoted, you can look at the `is_unpromoted` property of `BasicChat` or `FullChat`.\n   * This may be useful if you want to show some help for just created groups.\n   *\n   * @param protect If set to 1 the function creates group with protection initially enabled.\n   *     Only verified members are allowed in these groups\n   *     and end-to-end-encryption is always enabled.\n   */\n  public createGroupChat(accountId: T.U32, name: string, protect: boolean): Promise<T.U32> {\n    return (this._transport.request('create_group_chat', [accountId, name, protect] as RPC.Params)) as Promise<T.U32>;\n  }\n\n  /**\n   * Create a new broadcast list.\n   *\n   * Broadcast lists are similar to groups on the sending device,\n   * however, recipients get the messages in a read-only chat\n   * and will see who the other members are.\n   *\n   * For historical reasons, this function does not take a name directly,\n   * instead you have to set the name using dc_set_chat_name()\n   * after creating the broadcast list.\n   */\n  public createBroadcastList(accountId: T.U32): Promise<T.U32> {\n    return (this._transport.request('create_broadcast_list', [accountId] as RPC.Params)) as Promise<T.U32>;\n  }\n\n  /**\n   * Set group name.\n   *\n   * If the group is already _promoted_ (any message was sent to the group),\n   * all group members are informed by a special status message that is sent automatically by this function.\n   *\n   * Sends out #DC_EVENT_CHAT_MODIFIED and #DC_EVENT_MSGS_CHANGED if a status message was sent.\n   */\n  public setChatName(accountId: T.U32, chatId: T.U32, newName: string): Promise<null> {\n    return (this._transport.request('set_chat_name', [accountId, chatId, newName] as RPC.Params)) as Promise<null>;\n  }\n\n  /**\n   * Set group profile image.\n   *\n   * If the group is already _promoted_ (any message was sent to the group),\n   * all group members are informed by a special status message that is sent automatically by this function.\n   *\n   * Sends out #DC_EVENT_CHAT_MODIFIED and #DC_EVENT_MSGS_CHANGED if a status message was sent.\n   *\n   * To find out the profile image of a chat, use dc_chat_get_profile_image()\n   *\n   * @param image_path Full path of the image to use as the group image. The image will immediately be copied to the\n   *     `blobdir`; the original image will not be needed anymore.\n   *      If you pass null here, the group image is deleted (for promoted groups, all members are informed about\n   *      this change anyway).\n   */\n  public setChatProfileImage(accountId: T.U32, chatId: T.U32, imagePath: (string | null)): Promise<null> {\n    return (this._transport.request('set_chat_profile_image', [accountId, chatId, imagePath] as RPC.Params)) as Promise<null>;\n  }\n\n\n  public setChatVisibility(accountId: T.U32, chatId: T.U32, visibility: T.ChatVisibility): Promise<null> {\n    return (this._transport.request('set_chat_visibility', [accountId, chatId, visibility] as RPC.Params)) as Promise<null>;\n  }\n\n\n  public setChatEphemeralTimer(accountId: T.U32, chatId: T.U32, timer: T.U32): Promise<null> {\n    return (this._transport.request('set_chat_ephemeral_timer', [accountId, chatId, timer] as RPC.Params)) as Promise<null>;\n  }\n\n\n  public getChatEphemeralTimer(accountId: T.U32, chatId: T.U32): Promise<T.U32> {\n    return (this._transport.request('get_chat_ephemeral_timer', [accountId, chatId] as RPC.Params)) as Promise<T.U32>;\n  }\n\n  /**\n   * Add a message to the device-chat.\n   * Device-messages usually contain update information\n   * and some hints that are added during the program runs, multi-device etc.\n   * The device-message may be defined by a label;\n   * if a message with the same label was added or skipped before,\n   * the message is not added again, even if the message was deleted in between.\n   * If needed, the device-chat is created before.\n   *\n   * Sends the `MsgsChanged` event on success.\n   *\n   * Setting msg to None will prevent the device message with this label from being added in the future.\n   */\n  public addDeviceMessage(accountId: T.U32, label: string, msg: (T.MessageData | null)): Promise<(T.U32 | null)> {\n    return (this._transport.request('add_device_message', [accountId, label, msg] as RPC.Params)) as Promise<(T.U32 | null)>;\n  }\n\n  /**\n   *  Mark all messages in a chat as _noticed_.\n   *  _Noticed_ messages are no longer _fresh_ and do not count as being unseen\n   *  but are still waiting for being marked as \"seen\" using markseen_msgs()\n   *  (IMAP/MDNs is not done for noticed messages).\n   *\n   *  Calling this function usually results in the event #DC_EVENT_MSGS_NOTICED.\n   *  See also markseen_msgs().\n   */\n  public marknoticedChat(accountId: T.U32, chatId: T.U32): Promise<null> {\n    return (this._transport.request('marknoticed_chat', [accountId, chatId] as RPC.Params)) as Promise<null>;\n  }\n\n  /**\n   * Returns the message that is immediately followed by the last seen\n   * message.\n   * From the point of view of the user this is effectively\n   * \"first unread\", but in reality in the database a seen message\n   * _can_ be followed by a fresh (unseen) message\n   * if that message has not been individually marked as seen.\n   */\n  public getFirstUnreadMessageOfChat(accountId: T.U32, chatId: T.U32): Promise<(T.U32 | null)> {\n    return (this._transport.request('get_first_unread_message_of_chat', [accountId, chatId] as RPC.Params)) as Promise<(T.U32 | null)>;\n  }\n\n  /**\n   * Set mute duration of a chat.\n   *\n   * The UI can then call is_chat_muted() when receiving a new message\n   * to decide whether it should trigger an notification.\n   *\n   * Muted chats should not sound or vibrate\n   * and should not show a visual notification in the system area.\n   * Moreover, muted chats should be excluded from global badge counter\n   * (get_fresh_msgs() skips muted chats therefore)\n   * and the in-app, per-chat badge counter should use a less obtrusive color.\n   *\n   * Sends out #DC_EVENT_CHAT_MODIFIED.\n   */\n  public setChatMuteDuration(accountId: T.U32, chatId: T.U32, duration: T.MuteDuration): Promise<null> {\n    return (this._transport.request('set_chat_mute_duration', [accountId, chatId, duration] as RPC.Params)) as Promise<null>;\n  }\n\n  /**\n   * Check whether the chat is currently muted (can be changed by set_chat_mute_duration()).\n   *\n   * This is available as a standalone function outside of fullchat, because it might be only needed for notification\n   */\n  public isChatMuted(accountId: T.U32, chatId: T.U32): Promise<boolean> {\n    return (this._transport.request('is_chat_muted', [accountId, chatId] as RPC.Params)) as Promise<boolean>;\n  }\n\n  /**\n   * Mark messages as presented to the user.\n   * Typically, UIs call this function on scrolling through the message list,\n   * when the messages are presented at least for a little moment.\n   * The concrete action depends on the type of the chat and on the users settings\n   * (dc_msgs_presented() may be a better name therefore, but well. :)\n   *\n   * - For normal chats, the IMAP state is updated, MDN is sent\n   *   (if set_config()-options `mdns_enabled` is set)\n   *   and the internal state is changed to @ref DC_STATE_IN_SEEN to reflect these actions.\n   *\n   * - For contact requests, no IMAP or MDNs is done\n   *   and the internal state is not changed therefore.\n   *   See also marknoticed_chat().\n   *\n   * Moreover, timer is started for incoming ephemeral messages.\n   * This also happens for contact requests chats.\n   *\n   * This function updates `last_msg_id` configuration value\n   * to the maximum of the current value and IDs passed to this function.\n   * Bots which mark messages as seen can rely on this side effect\n   * to avoid updating `last_msg_id` value manually.\n   *\n   * One #DC_EVENT_MSGS_NOTICED event is emitted per modified chat.\n   */\n  public markseenMsgs(accountId: T.U32, msgIds: (T.U32)[]): Promise<null> {\n    return (this._transport.request('markseen_msgs', [accountId, msgIds] as RPC.Params)) as Promise<null>;\n  }\n\n  /**\n   * Returns all messages of a particular chat.\n   * If `add_daymarker` is `true`, it will return them as\n   * `DC_MSG_ID_DAYMARKER`, e.g. [1234, 1237, 9, 1239].\n   */\n  public getMessageIds(accountId: T.U32, chatId: T.U32, infoOnly: boolean, addDaymarker: boolean): Promise<(T.U32)[]> {\n    return (this._transport.request('get_message_ids', [accountId, chatId, infoOnly, addDaymarker] as RPC.Params)) as Promise<(T.U32)[]>;\n  }\n\n\n  public getMessageListItems(accountId: T.U32, chatId: T.U32, infoOnly: boolean, addDaymarker: boolean): Promise<(T.MessageListItem)[]> {\n    return (this._transport.request('get_message_list_items', [accountId, chatId, infoOnly, addDaymarker] as RPC.Params)) as Promise<(T.MessageListItem)[]>;\n  }\n\n\n  public getMessage(accountId: T.U32, msgId: T.U32): Promise<T.Message> {\n    return (this._transport.request('get_message', [accountId, msgId] as RPC.Params)) as Promise<T.Message>;\n  }\n\n\n  public getMessageHtml(accountId: T.U32, messageId: T.U32): Promise<(string | null)> {\n    return (this._transport.request('get_message_html', [accountId, messageId] as RPC.Params)) as Promise<(string | null)>;\n  }\n\n  /**\n   * get multiple messages in one call,\n   * if loading one message fails the error is stored in the result object in it's place.\n   *\n   * this is the batch variant of [get_message]\n   */\n  public getMessages(accountId: T.U32, messageIds: (T.U32)[]): Promise<Record<T.U32, T.MessageLoadResult>> {\n    return (this._transport.request('get_messages', [accountId, messageIds] as RPC.Params)) as Promise<Record<T.U32, T.MessageLoadResult>>;\n  }\n\n  /**\n   * Fetch info desktop needs for creating a notification for a message\n   */\n  public getMessageNotificationInfo(accountId: T.U32, messageId: T.U32): Promise<T.MessageNotificationInfo> {\n    return (this._transport.request('get_message_notification_info', [accountId, messageId] as RPC.Params)) as Promise<T.MessageNotificationInfo>;\n  }\n\n  /**\n   * Delete messages. The messages are deleted on the current device and\n   * on the IMAP server.\n   */\n  public deleteMessages(accountId: T.U32, messageIds: (T.U32)[]): Promise<null> {\n    return (this._transport.request('delete_messages', [accountId, messageIds] as RPC.Params)) as Promise<null>;\n  }\n\n  /**\n   * Delete messages. The messages are deleted on the current device,\n   * on the IMAP server and also for all chat members\n   */\n  public deleteMessagesForAll(accountId: T.U32, messageIds: (T.U32)[]): Promise<null> {\n    return (this._transport.request('delete_messages_for_all', [accountId, messageIds] as RPC.Params)) as Promise<null>;\n  }\n\n  /**\n   * Get an informational text for a single message. The text is multiline and may\n   * contain e.g. the raw text of the message.\n   *\n   * The max. text returned is typically longer (about 100000 characters) than the\n   * max. text returned by dc_msg_get_text() (about 30000 characters).\n   */\n  public getMessageInfo(accountId: T.U32, messageId: T.U32): Promise<string> {\n    return (this._transport.request('get_message_info', [accountId, messageId] as RPC.Params)) as Promise<string>;\n  }\n\n  /**\n   * Returns additional information for single message.\n   */\n  public getMessageInfoObject(accountId: T.U32, messageId: T.U32): Promise<T.MessageInfo> {\n    return (this._transport.request('get_message_info_object', [accountId, messageId] as RPC.Params)) as Promise<T.MessageInfo>;\n  }\n\n  /**\n   * Returns contacts that sent read receipts and the time of reading.\n   */\n  public getMessageReadReceipts(accountId: T.U32, messageId: T.U32): Promise<(T.MessageReadReceipt)[]> {\n    return (this._transport.request('get_message_read_receipts', [accountId, messageId] as RPC.Params)) as Promise<(T.MessageReadReceipt)[]>;\n  }\n\n  /**\n   * Asks the core to start downloading a message fully.\n   * This function is typically called when the user hits the \"Download\" button\n   * that is shown by the UI in case `download_state` is `'Available'` or `'Failure'`\n   *\n   * On success, the @ref DC_MSG \"view type of the message\" may change\n   * or the message may be replaced completely by one or more messages with other message IDs.\n   * That may happen e.g. in cases where the message was encrypted\n   * and the type could not be determined without fully downloading.\n   * Downloaded content can be accessed as usual after download.\n   *\n   * To reflect these changes a @ref DC_EVENT_MSGS_CHANGED event will be emitted.\n   */\n  public downloadFullMessage(accountId: T.U32, messageId: T.U32): Promise<null> {\n    return (this._transport.request('download_full_message', [accountId, messageId] as RPC.Params)) as Promise<null>;\n  }\n\n  /**\n   * Search messages containing the given query string.\n   * Searching can be done globally (chat_id=None) or in a specified chat only (chat_id set).\n   *\n   * Global search results are typically displayed using dc_msg_get_summary(), chat\n   * search results may just highlight the corresponding messages and present a\n   * prev/next button.\n   *\n   * For the global search, the result is limited to 1000 messages,\n   * this allows an incremental search done fast.\n   * So, when getting exactly 1000 messages, the result actually may be truncated;\n   * the UIs may display sth. like \"1000+ messages found\" in this case.\n   * The chat search (if chat_id is set) is not limited.\n   */\n  public searchMessages(accountId: T.U32, query: string, chatId: (T.U32 | null)): Promise<(T.U32)[]> {\n    return (this._transport.request('search_messages', [accountId, query, chatId] as RPC.Params)) as Promise<(T.U32)[]>;\n  }\n\n\n  public messageIdsToSearchResults(accountId: T.U32, messageIds: (T.U32)[]): Promise<Record<T.U32, T.MessageSearchResult>> {\n    return (this._transport.request('message_ids_to_search_results', [accountId, messageIds] as RPC.Params)) as Promise<Record<T.U32, T.MessageSearchResult>>;\n  }\n\n\n  public saveMsgs(accountId: T.U32, messageIds: (T.U32)[]): Promise<null> {\n    return (this._transport.request('save_msgs', [accountId, messageIds] as RPC.Params)) as Promise<null>;\n  }\n\n  /**\n   * Get a single contact options by ID.\n   */\n  public getContact(accountId: T.U32, contactId: T.U32): Promise<T.Contact> {\n    return (this._transport.request('get_contact', [accountId, contactId] as RPC.Params)) as Promise<T.Contact>;\n  }\n\n  /**\n   * Add a single contact as a result of an explicit user action.\n   *\n   * Returns contact id of the created or existing contact\n   */\n  public createContact(accountId: T.U32, email: string, name: (string | null)): Promise<T.U32> {\n    return (this._transport.request('create_contact', [accountId, email, name] as RPC.Params)) as Promise<T.U32>;\n  }\n\n  /**\n   * Returns contact id of the created or existing DM chat with that contact\n   */\n  public createChatByContactId(accountId: T.U32, contactId: T.U32): Promise<T.U32> {\n    return (this._transport.request('create_chat_by_contact_id', [accountId, contactId] as RPC.Params)) as Promise<T.U32>;\n  }\n\n\n  public blockContact(accountId: T.U32, contactId: T.U32): Promise<null> {\n    return (this._transport.request('block_contact', [accountId, contactId] as RPC.Params)) as Promise<null>;\n  }\n\n\n  public unblockContact(accountId: T.U32, contactId: T.U32): Promise<null> {\n    return (this._transport.request('unblock_contact', [accountId, contactId] as RPC.Params)) as Promise<null>;\n  }\n\n\n  public getBlockedContacts(accountId: T.U32): Promise<(T.Contact)[]> {\n    return (this._transport.request('get_blocked_contacts', [accountId] as RPC.Params)) as Promise<(T.Contact)[]>;\n  }\n\n\n  public getContactIds(accountId: T.U32, listFlags: T.U32, query: (string | null)): Promise<(T.U32)[]> {\n    return (this._transport.request('get_contact_ids', [accountId, listFlags, query] as RPC.Params)) as Promise<(T.U32)[]>;\n  }\n\n  /**\n   * Get a list of contacts.\n   * (formerly called getContacts2 in desktop)\n   */\n  public getContacts(accountId: T.U32, listFlags: T.U32, query: (string | null)): Promise<(T.Contact)[]> {\n    return (this._transport.request('get_contacts', [accountId, listFlags, query] as RPC.Params)) as Promise<(T.Contact)[]>;\n  }\n\n\n  public getContactsByIds(accountId: T.U32, ids: (T.U32)[]): Promise<Record<T.U32, T.Contact>> {\n    return (this._transport.request('get_contacts_by_ids', [accountId, ids] as RPC.Params)) as Promise<Record<T.U32, T.Contact>>;\n  }\n\n\n  public deleteContact(accountId: T.U32, contactId: T.U32): Promise<null> {\n    return (this._transport.request('delete_contact', [accountId, contactId] as RPC.Params)) as Promise<null>;\n  }\n\n  /**\n   * Resets contact encryption.\n   */\n  public resetContactEncryption(accountId: T.U32, contactId: T.U32): Promise<null> {\n    return (this._transport.request('reset_contact_encryption', [accountId, contactId] as RPC.Params)) as Promise<null>;\n  }\n\n  /**\n   * Sets display name for existing contact.\n   */\n  public changeContactName(accountId: T.U32, contactId: T.U32, name: string): Promise<null> {\n    return (this._transport.request('change_contact_name', [accountId, contactId, name] as RPC.Params)) as Promise<null>;\n  }\n\n  /**\n   * Get encryption info for a contact.\n   * Get a multi-line encryption info, containing your fingerprint and the\n   * fingerprint of the contact, used e.g. to compare the fingerprints for a simple out-of-band verification.\n   */\n  public getContactEncryptionInfo(accountId: T.U32, contactId: T.U32): Promise<string> {\n    return (this._transport.request('get_contact_encryption_info', [accountId, contactId] as RPC.Params)) as Promise<string>;\n  }\n\n  /**\n   * Check if an e-mail address belongs to a known and unblocked contact.\n   * To get a list of all known and unblocked contacts, use contacts_get_contacts().\n   *\n   * To validate an e-mail address independently of the contact database\n   * use check_email_validity().\n   */\n  public lookupContactIdByAddr(accountId: T.U32, addr: string): Promise<(T.U32 | null)> {\n    return (this._transport.request('lookup_contact_id_by_addr', [accountId, addr] as RPC.Params)) as Promise<(T.U32 | null)>;\n  }\n\n  /**\n   * Parses a vCard file located at the given path. Returns contacts in their original order.\n   */\n  public parseVcard(path: string): Promise<(T.VcardContact)[]> {\n    return (this._transport.request('parse_vcard', [path] as RPC.Params)) as Promise<(T.VcardContact)[]>;\n  }\n\n  /**\n   * Imports contacts from a vCard file located at the given path.\n   *\n   * Returns the ids of created/modified contacts in the order they appear in the vCard.\n   */\n  public importVcard(accountId: T.U32, path: string): Promise<(T.U32)[]> {\n    return (this._transport.request('import_vcard', [accountId, path] as RPC.Params)) as Promise<(T.U32)[]>;\n  }\n\n  /**\n   * Imports contacts from a vCard.\n   *\n   * Returns the ids of created/modified contacts in the order they appear in the vCard.\n   */\n  public importVcardContents(accountId: T.U32, vcard: string): Promise<(T.U32)[]> {\n    return (this._transport.request('import_vcard_contents', [accountId, vcard] as RPC.Params)) as Promise<(T.U32)[]>;\n  }\n\n  /**\n   * Returns a vCard containing contacts with the given ids.\n   */\n  public makeVcard(accountId: T.U32, contacts: (T.U32)[]): Promise<string> {\n    return (this._transport.request('make_vcard', [accountId, contacts] as RPC.Params)) as Promise<string>;\n  }\n\n  /**\n   * Sets vCard containing the given contacts to the message draft.\n   */\n  public setDraftVcard(accountId: T.U32, msgId: T.U32, contacts: (T.U32)[]): Promise<null> {\n    return (this._transport.request('set_draft_vcard', [accountId, msgId, contacts] as RPC.Params)) as Promise<null>;\n  }\n\n  /**\n   * Returns the [`ChatId`] for the 1:1 chat with `contact_id` if it exists.\n   *\n   * If it does not exist, `None` is returned.\n   */\n  public getChatIdByContactId(accountId: T.U32, contactId: T.U32): Promise<(T.U32 | null)> {\n    return (this._transport.request('get_chat_id_by_contact_id', [accountId, contactId] as RPC.Params)) as Promise<(T.U32 | null)>;\n  }\n\n  /**\n   * Returns all message IDs of the given types in a chat.\n   * Typically used to show a gallery.\n   *\n   * The list is already sorted and starts with the oldest message.\n   * Clients should not try to re-sort the list as this would be an expensive action\n   * and would result in inconsistencies between clients.\n   *\n   * Setting `chat_id` to `None` (`null` in typescript) means get messages with media\n   * from any chat of the currently used account.\n   */\n  public getChatMedia(accountId: T.U32, chatId: (T.U32 | null), messageType: T.Viewtype, orMessageType2: (T.Viewtype | null), orMessageType3: (T.Viewtype | null)): Promise<(T.U32)[]> {\n    return (this._transport.request('get_chat_media', [accountId, chatId, messageType, orMessageType2, orMessageType3] as RPC.Params)) as Promise<(T.U32)[]>;\n  }\n\n\n  public exportBackup(accountId: T.U32, destination: string, passphrase: (string | null)): Promise<null> {\n    return (this._transport.request('export_backup', [accountId, destination, passphrase] as RPC.Params)) as Promise<null>;\n  }\n\n\n  public importBackup(accountId: T.U32, path: string, passphrase: (string | null)): Promise<null> {\n    return (this._transport.request('import_backup', [accountId, path, passphrase] as RPC.Params)) as Promise<null>;\n  }\n\n  /**\n   * Offers a backup for remote devices to retrieve.\n   *\n   * Can be cancelled by stopping the ongoing process.  Success or failure can be tracked\n   * via the `ImexProgress` event which should either reach `1000` for success or `0` for\n   * failure.\n   *\n   * This **stops IO** while it is running.\n   *\n   * Returns once a remote device has retrieved the backup, or is cancelled.\n   */\n  public provideBackup(accountId: T.U32): Promise<null> {\n    return (this._transport.request('provide_backup', [accountId] as RPC.Params)) as Promise<null>;\n  }\n\n  /**\n   * Returns the text of the QR code for the running [`CommandApi::provide_backup`].\n   *\n   * This QR code text can be used in [`CommandApi::get_backup`] on a second device to\n   * retrieve the backup and setup this second device.\n   *\n   * This call will block until the QR code is ready,\n   * even if there is no concurrent call to [`CommandApi::provide_backup`],\n   * but will fail after 60 seconds to avoid deadlocks.\n   */\n  public getBackupQr(accountId: T.U32): Promise<string> {\n    return (this._transport.request('get_backup_qr', [accountId] as RPC.Params)) as Promise<string>;\n  }\n\n  /**\n   * Returns the rendered QR code for the running [`CommandApi::provide_backup`].\n   *\n   * This QR code can be used in [`CommandApi::get_backup`] on a second device to\n   * retrieve the backup and setup this second device.\n   *\n   * This call will block until the QR code is ready,\n   * even if there is no concurrent call to [`CommandApi::provide_backup`],\n   * but will fail after 60 seconds to avoid deadlocks.\n   *\n   * Returns the QR code rendered as an SVG image.\n   */\n  public getBackupQrSvg(accountId: T.U32): Promise<string> {\n    return (this._transport.request('get_backup_qr_svg', [accountId] as RPC.Params)) as Promise<string>;\n  }\n\n  /**\n   * Gets a backup from a remote provider.\n   *\n   * This retrieves the backup from a remote device over the network and imports it into\n   * the current device.\n   *\n   * Can be cancelled by stopping the ongoing process.\n   *\n   * Do not forget to call start_io on the account after a successful import,\n   * otherwise it will not connect to the email server.\n   */\n  public getBackup(accountId: T.U32, qrText: string): Promise<null> {\n    return (this._transport.request('get_backup', [accountId, qrText] as RPC.Params)) as Promise<null>;\n  }\n\n  /**\n   * Indicate that the network likely has come back.\n   * or just that the network conditions might have changed\n   */\n  public maybeNetwork(): Promise<null> {\n    return (this._transport.request('maybe_network', [] as RPC.Params)) as Promise<null>;\n  }\n\n  /**\n   * Get the current connectivity, i.e. whether the device is connected to the IMAP server.\n   * One of:\n   * - DC_CONNECTIVITY_NOT_CONNECTED (1000-1999): Show e.g. the string \"Not connected\" or a red dot\n   * - DC_CONNECTIVITY_CONNECTING (2000-2999): Show e.g. the string \"Connecting\u2026\" or a yellow dot\n   * - DC_CONNECTIVITY_WORKING (3000-3999): Show e.g. the string \"Getting new messages\" or a spinning wheel\n   * - DC_CONNECTIVITY_CONNECTED (>=4000): Show e.g. the string \"Connected\" or a green dot\n   *\n   * We don't use exact values but ranges here so that we can split up\n   * states into multiple states in the future.\n   *\n   * Meant as a rough overview that can be shown\n   * e.g. in the title of the main screen.\n   *\n   * If the connectivity changes, a #DC_EVENT_CONNECTIVITY_CHANGED will be emitted.\n   */\n  public getConnectivity(accountId: T.U32): Promise<T.U32> {\n    return (this._transport.request('get_connectivity', [accountId] as RPC.Params)) as Promise<T.U32>;\n  }\n\n  /**\n   * Get an overview of the current connectivity, and possibly more statistics.\n   * Meant to give the user more insight about the current status than\n   * the basic connectivity info returned by get_connectivity(); show this\n   * e.g., if the user taps on said basic connectivity info.\n   *\n   * If this page changes, a #DC_EVENT_CONNECTIVITY_CHANGED will be emitted.\n   *\n   * This comes as an HTML from the core so that we can easily improve it\n   * and the improvement instantly reaches all UIs.\n   */\n  public getConnectivityHtml(accountId: T.U32): Promise<string> {\n    return (this._transport.request('get_connectivity_html', [accountId] as RPC.Params)) as Promise<string>;\n  }\n\n\n  public getLocations(accountId: T.U32, chatId: (T.U32 | null), contactId: (T.U32 | null), timestampBegin: T.I64, timestampEnd: T.I64): Promise<(T.Location)[]> {\n    return (this._transport.request('get_locations', [accountId, chatId, contactId, timestampBegin, timestampEnd] as RPC.Params)) as Promise<(T.Location)[]>;\n  }\n\n\n  public sendWebxdcStatusUpdate(accountId: T.U32, instanceMsgId: T.U32, updateStr: string, descr: (string | null)): Promise<null> {\n    return (this._transport.request('send_webxdc_status_update', [accountId, instanceMsgId, updateStr, descr] as RPC.Params)) as Promise<null>;\n  }\n\n\n  public sendWebxdcRealtimeData(accountId: T.U32, instanceMsgId: T.U32, data: (T.U8)[]): Promise<null> {\n    return (this._transport.request('send_webxdc_realtime_data', [accountId, instanceMsgId, data] as RPC.Params)) as Promise<null>;\n  }\n\n\n  public sendWebxdcRealtimeAdvertisement(accountId: T.U32, instanceMsgId: T.U32): Promise<null> {\n    return (this._transport.request('send_webxdc_realtime_advertisement', [accountId, instanceMsgId] as RPC.Params)) as Promise<null>;\n  }\n\n\n  public leaveWebxdcRealtime(accountId: T.U32, instanceMessageId: T.U32): Promise<null> {\n    return (this._transport.request('leave_webxdc_realtime', [accountId, instanceMessageId] as RPC.Params)) as Promise<null>;\n  }\n\n\n  public getWebxdcStatusUpdates(accountId: T.U32, instanceMsgId: T.U32, lastKnownSerial: T.U32): Promise<string> {\n    return (this._transport.request('get_webxdc_status_updates', [accountId, instanceMsgId, lastKnownSerial] as RPC.Params)) as Promise<string>;\n  }\n\n  /**\n   * Get info from a webxdc message\n   */\n  public getWebxdcInfo(accountId: T.U32, instanceMsgId: T.U32): Promise<T.WebxdcMessageInfo> {\n    return (this._transport.request('get_webxdc_info', [accountId, instanceMsgId] as RPC.Params)) as Promise<T.WebxdcMessageInfo>;\n  }\n\n  /**\n   * Get href from a WebxdcInfoMessage which might include a hash holding\n   * information about a specific position or state in a webxdc app (optional)\n   */\n  public getWebxdcHref(accountId: T.U32, infoMsgId: T.U32): Promise<(string | null)> {\n    return (this._transport.request('get_webxdc_href', [accountId, infoMsgId] as RPC.Params)) as Promise<(string | null)>;\n  }\n\n  /**\n   * Get blob encoded as base64 from a webxdc message\n   *\n   * path is the path of the file within webxdc archive\n   */\n  public getWebxdcBlob(accountId: T.U32, instanceMsgId: T.U32, path: string): Promise<string> {\n    return (this._transport.request('get_webxdc_blob', [accountId, instanceMsgId, path] as RPC.Params)) as Promise<string>;\n  }\n\n  /**\n   * Sets Webxdc file as integration.\n   * `file` is the .xdc to use as Webxdc integration.\n   */\n  public setWebxdcIntegration(accountId: T.U32, filePath: string): Promise<null> {\n    return (this._transport.request('set_webxdc_integration', [accountId, filePath] as RPC.Params)) as Promise<null>;\n  }\n\n  /**\n   * Returns Webxdc instance used for optional integrations.\n   * UI can open the Webxdc as usual.\n   * Returns `None` if there is no integration; the caller can add one using `set_webxdc_integration` then.\n   * `integrate_for` is the chat to get the integration for.\n   */\n  public initWebxdcIntegration(accountId: T.U32, chatId: (T.U32 | null)): Promise<(T.U32 | null)> {\n    return (this._transport.request('init_webxdc_integration', [accountId, chatId] as RPC.Params)) as Promise<(T.U32 | null)>;\n  }\n\n  /**\n   * Makes an HTTP GET request and returns a response.\n   *\n   * `url` is the HTTP or HTTPS URL.\n   */\n  public getHttpResponse(accountId: T.U32, url: string): Promise<T.HttpResponse> {\n    return (this._transport.request('get_http_response', [accountId, url] as RPC.Params)) as Promise<T.HttpResponse>;\n  }\n\n  /**\n   * Forward messages to another chat.\n   *\n   * All types of messages can be forwarded,\n   * however, they will be flagged as such (dc_msg_is_forwarded() is set).\n   *\n   * Original sender, info-state and webxdc updates are not forwarded on purpose.\n   */\n  public forwardMessages(accountId: T.U32, messageIds: (T.U32)[], chatId: T.U32): Promise<null> {\n    return (this._transport.request('forward_messages', [accountId, messageIds, chatId] as RPC.Params)) as Promise<null>;\n  }\n\n  /**\n   * Resend messages and make information available for newly added chat members.\n   * Resending sends out the original message, however, recipients and webxdc-status may differ.\n   * Clients that already have the original message can still ignore the resent message as\n   * they have tracked the state by dedicated updates.\n   *\n   * Some messages cannot be resent, eg. info-messages, drafts, already pending messages or messages that are not sent by SELF.\n   *\n   * message_ids all message IDs that should be resend. All messages must belong to the same chat.\n   */\n  public resendMessages(accountId: T.U32, messageIds: (T.U32)[]): Promise<null> {\n    return (this._transport.request('resend_messages', [accountId, messageIds] as RPC.Params)) as Promise<null>;\n  }\n\n\n  public sendSticker(accountId: T.U32, chatId: T.U32, stickerPath: string): Promise<T.U32> {\n    return (this._transport.request('send_sticker', [accountId, chatId, stickerPath] as RPC.Params)) as Promise<T.U32>;\n  }\n\n  /**\n   * Send a reaction to message.\n   *\n   * Reaction is a string of emojis separated by spaces. Reaction to a\n   * single message can be sent multiple times. The last reaction\n   * received overrides all previously received reactions. It is\n   * possible to remove all reactions by sending an empty string.\n   */\n  public sendReaction(accountId: T.U32, messageId: T.U32, reaction: (string)[]): Promise<T.U32> {\n    return (this._transport.request('send_reaction', [accountId, messageId, reaction] as RPC.Params)) as Promise<T.U32>;\n  }\n\n  /**\n   * Returns reactions to the message.\n   */\n  public getMessageReactions(accountId: T.U32, messageId: T.U32): Promise<(T.Reactions | null)> {\n    return (this._transport.request('get_message_reactions', [accountId, messageId] as RPC.Params)) as Promise<(T.Reactions | null)>;\n  }\n\n\n  public sendMsg(accountId: T.U32, chatId: T.U32, data: T.MessageData): Promise<T.U32> {\n    return (this._transport.request('send_msg', [accountId, chatId, data] as RPC.Params)) as Promise<T.U32>;\n  }\n\n\n  public sendEditRequest(accountId: T.U32, msgId: T.U32, newText: string): Promise<null> {\n    return (this._transport.request('send_edit_request', [accountId, msgId, newText] as RPC.Params)) as Promise<null>;\n  }\n\n  /**\n   * Checks if messages can be sent to a given chat.\n   */\n  public canSend(accountId: T.U32, chatId: T.U32): Promise<boolean> {\n    return (this._transport.request('can_send', [accountId, chatId] as RPC.Params)) as Promise<boolean>;\n  }\n\n  /**\n   * Saves a file copy at the user-provided path.\n   *\n   * Fails if file already exists at the provided path.\n   */\n  public saveMsgFile(accountId: T.U32, msgId: T.U32, path: string): Promise<null> {\n    return (this._transport.request('save_msg_file', [accountId, msgId, path] as RPC.Params)) as Promise<null>;\n  }\n\n\n  public removeDraft(accountId: T.U32, chatId: T.U32): Promise<null> {\n    return (this._transport.request('remove_draft', [accountId, chatId] as RPC.Params)) as Promise<null>;\n  }\n\n  /**\n   *  Get draft for a chat, if any.\n   */\n  public getDraft(accountId: T.U32, chatId: T.U32): Promise<(T.Message | null)> {\n    return (this._transport.request('get_draft', [accountId, chatId] as RPC.Params)) as Promise<(T.Message | null)>;\n  }\n\n\n  public sendVideochatInvitation(accountId: T.U32, chatId: T.U32): Promise<T.U32> {\n    return (this._transport.request('send_videochat_invitation', [accountId, chatId] as RPC.Params)) as Promise<T.U32>;\n  }\n\n\n  public miscGetStickerFolder(accountId: T.U32): Promise<string> {\n    return (this._transport.request('misc_get_sticker_folder', [accountId] as RPC.Params)) as Promise<string>;\n  }\n\n  /**\n   * Saves a sticker to a collection/folder in the account's sticker folder.\n   */\n  public miscSaveSticker(accountId: T.U32, msgId: T.U32, collection: string): Promise<null> {\n    return (this._transport.request('misc_save_sticker', [accountId, msgId, collection] as RPC.Params)) as Promise<null>;\n  }\n\n  /**\n   * for desktop, get stickers from stickers folder,\n   * grouped by the collection/folder they are in.\n   */\n  public miscGetStickers(accountId: T.U32): Promise<Record<string, (string)[]>> {\n    return (this._transport.request('misc_get_stickers', [accountId] as RPC.Params)) as Promise<Record<string, (string)[]>>;\n  }\n\n  /**\n   * Returns the messageid of the sent message\n   */\n  public miscSendTextMessage(accountId: T.U32, chatId: T.U32, text: string): Promise<T.U32> {\n    return (this._transport.request('misc_send_text_message', [accountId, chatId, text] as RPC.Params)) as Promise<T.U32>;\n  }\n\n  /**\n   * Send a message to a chat.\n   *\n   * This function returns after the message has been placed in the sending queue.\n   * This does not imply that the message was really sent out yet.\n   * However, from your view, you're done with the message.\n   * Sooner or later it will find its way.\n   *\n   * **Attaching files:**\n   *\n   * Pass the file path in the `file` parameter.\n   * If `file` is not in the blob directory yet,\n   * it will be copied into the blob directory.\n   * If you want, you can delete the file immediately after this function returns.\n   *\n   * You can also write the attachment directly into the blob directory\n   * and then pass the path as the `file` parameter;\n   * this will prevent an unnecessary copying of the file.\n   *\n   * In `filename`, you can pass the original name of the file,\n   * which will then be shown in the UI.\n   * in this case the current name of `file` on the filesystem will be ignored.\n   *\n   * In order to deduplicate files that contain the same data,\n   * the file will be named `<hash>.<extension>`, e.g. `ce940175885d7b78f7b7e9f1396611f.jpg`.\n   *\n   * NOTE:\n   * - This function will rename the file. To get the new file path, call `get_file()`.\n   * - The file must not be modified after this function was called.\n   * - Images etc. will NOT be recoded.\n   *   In order to recode images,\n   *   use `misc_set_draft` and pass `Image` as the viewtype.\n   */\n  public miscSendMsg(accountId: T.U32, chatId: T.U32, text: (string | null), file: (string | null), filename: (string | null), location: ([T.F64, T.F64] | null), quotedMessageId: (T.U32 | null)): Promise<[T.U32, T.Message]> {\n    return (this._transport.request('misc_send_msg', [accountId, chatId, text, file, filename, location, quotedMessageId] as RPC.Params)) as Promise<[T.U32, T.Message]>;\n  }\n\n\n  public miscSetDraft(accountId: T.U32, chatId: T.U32, text: (string | null), file: (string | null), filename: (string | null), quotedMessageId: (T.U32 | null), viewType: (T.Viewtype | null)): Promise<null> {\n    return (this._transport.request('misc_set_draft', [accountId, chatId, text, file, filename, quotedMessageId, viewType] as RPC.Params)) as Promise<null>;\n  }\n\n\n  public miscSendDraft(accountId: T.U32, chatId: T.U32): Promise<T.U32> {\n    return (this._transport.request('misc_send_draft', [accountId, chatId] as RPC.Params)) as Promise<T.U32>;\n  }\n\n\n}\n", "export * from \"./client.js\";\nexport * from \"./jsonrpc.js\";\nexport * from \"./websocket.js\";\n", "// Adapted from https://github.com/scottcorgan/tiny-emitter\n// (c) Scott Corgan\n// License: MIT\n\nexport type Arguments<T> = [T] extends [(...args: infer U) => any] ? U : [T] extends [void] ? [] : [T];\n\nexport type EventsT = Record<string, (...args: any) => void>\n\ntype Callback = (...args: any[]) => void\n\ntype EventData = {\n  callback: Callback\n  ctx?: any\n}\n\nexport class Emitter<T extends EventsT = any> {\n  e: Map<keyof T, EventData[]>\n  constructor () {\n    this.e = new Map()\n  }\n  on<E extends keyof T>(event: E, callback: T[E], ctx?: any) {\n    return this._on(event, callback, ctx)\n  }\n\n  private _on<E extends keyof T>(event: E, callback: Callback, ctx?: any) {\n    const data: EventData = { callback, ctx }\n    if (!this.e.has(event)) this.e.set(event, [])\n    this.e.get(event)!.push(data)\n    return this;\n  }\n\n  once<E extends keyof T>(event: E, callback: T[E], ctx?: any) {\n    const listener = (...args: any[]) => {\n      this.off(event, callback)\n      callback.apply(ctx, args)\n    }\n    this._on(event, listener, ctx)\n  }\n\n  // TODO: the any here is a temporary measure because I couldn't get the \n  // typescript inference right.\n  emit<E extends keyof T>(event: E | string, ...args: Arguments<T[E]> | any[]) {\n    if (!this.e.has(event)) return\n    this.e.get(event)!.forEach(data => {\n      data.callback.apply(data.ctx, args)\n    })\n    return this;\n  }\n\n  off<E extends keyof T>(event: E, callback?: T[E]) {\n    if (!this.e.has(event)) return\n    const existing = this.e.get(event)!\n    const filtered = existing.filter(data => {\n      return data.callback !== callback\n    })\n    if (filtered.length) {\n      this.e.set(event, filtered)\n    } else {\n      this.e.delete(event)\n    }\n    return this\n  }\n}\n", "import { Emitter } from \"./util/emitter.js\";\nimport { Request, Response, Message, Error, Params, Id } from \"./jsonrpc.js\";\n\nexport interface Transport {\n  request: (method: string, params?: Params) => Promise<unknown>;\n  notification: (method: string, params?: Params) => void;\n}\n\ntype RequestMap = Map<\n  Id,\n  { resolve: (result: unknown) => void; reject: (error: Error) => void }\n>;\n\ntype ClientEvents<T> = {\n  request: (request: Request) => void;\n} & T;\n\nexport abstract class BaseTransport<T = {}>\n  extends Emitter<ClientEvents<T>>\n  implements Transport\n{\n  private _requests: RequestMap = new Map();\n  private _requestId = 0;\n  _send(_message: Message): void {\n    throw new Error(\"_send method not implemented\");\n  }\n\n  close() {}\n\n  protected _onmessage(message: Message): void {\n    if ((message as Request).method) {\n      const request = message as Request;\n      this.emit(\"request\", request);\n    }\n\n    if (!message.id) return; // TODO: Handle error;\n    const response = message as Response;\n    if (!response.id) return; // TODO: Handle error.\n    const handler = this._requests.get(response.id);\n    if (!handler) return; // TODO: Handle error.\n    this._requests.delete(response.id);\n    if (response.error) handler.reject(response.error);\n    else handler.resolve(response.result);\n  }\n\n  notification(method: string, params?: Params): void {\n    const request: Request = {\n      jsonrpc: \"2.0\",\n      method,\n      id: 0,\n      params,\n    };\n    this._send(request);\n  }\n\n  request(method: string, params?: Params): Promise<unknown> {\n    // console.log('request', { method, params }, 'this', this)\n    const id: number = ++this._requestId;\n    const request: Request = {\n      jsonrpc: \"2.0\",\n      method,\n      id,\n      params,\n    };\n    this._send(request as Message);\n    return new Promise((resolve, reject) => {\n      this._requests.set(id, { resolve, reject });\n    });\n  }\n}\n", "import WebSocket from \"isomorphic-ws\";\nimport { Message } from \"./jsonrpc.js\";\nimport { BaseTransport } from \"./client.js\";\nimport { Emitter, EventsT } from \"./util/emitter.js\";\n\ntype WebsocketOptions = {\n  reconnectDecay: number;\n  reconnectInterval: number;\n  maxReconnectInterval: number;\n};\n\nexport type WebSocketErrorEvent = WebSocket.ErrorEvent;\n\nexport interface WebsocketEvents extends EventsT {\n  connect: () => void;\n  disconnect: () => void;\n  error: (error: WebSocket.ErrorEvent) => void;\n}\n\nexport class WebsocketTransport extends BaseTransport<WebsocketEvents> {\n  _socket: ReconnectingWebsocket;\n  get reconnectAttempts() {\n    return this._socket.reconnectAttempts;\n  }\n  get connected() {\n    return this._socket.connected;\n  }\n  constructor(public url: string, options?: WebsocketOptions) {\n    super();\n    const onmessage = (event: WebSocket.MessageEvent) => {\n      const message: Message = JSON.parse(event.data as string);\n      this._onmessage(message);\n    };\n    this._socket = new ReconnectingWebsocket(url, onmessage, options);\n\n    this._socket.on(\"connect\", () => this.emit(\"connect\"));\n    this._socket.on(\"disconnect\", () => this.emit(\"disconnect\"));\n    this._socket.on(\"error\", (error: WebSocket.ErrorEvent) =>\n      this.emit(\"error\", error)\n    );\n  }\n\n  _send(message: Message): void {\n    const serialized = JSON.stringify(message);\n    this._socket.send(serialized);\n  }\n\n  close() {\n    this._socket.close();\n  }\n}\n\nclass ReconnectingWebsocket extends Emitter<WebsocketEvents> {\n  socket!: WebSocket;\n  ready!: Promise<void>;\n  options: WebsocketOptions;\n\n  private preopenQueue: string[] = [];\n  private _connected = false;\n  private _reconnectAttempts = 0;\n\n  onmessage: (event: WebSocket.MessageEvent) => void;\n  closed = false;\n\n  constructor(\n    public url: string,\n    onmessage: (event: WebSocket.MessageEvent) => void,\n    options?: WebsocketOptions\n  ) {\n    super();\n    this.options = {\n      reconnectDecay: 1.5,\n      reconnectInterval: 1000,\n      maxReconnectInterval: 10000,\n      ...options,\n    };\n    this.onmessage = onmessage;\n    this._reconnect();\n  }\n\n  get reconnectAttempts() {\n    return this._reconnectAttempts;\n  }\n\n  private _reconnect() {\n    if (this.closed) return;\n    let resolveReady!: (_: void) => void;\n    this.ready = new Promise((resolve) => (resolveReady = resolve));\n\n    this.socket = new WebSocket(this.url);\n    this.socket.onmessage = this.onmessage.bind(this);\n    this.socket.onopen = (_event) => {\n      this._reconnectAttempts = 0;\n      this._connected = true;\n      while (this.preopenQueue.length) {\n        this.socket.send(this.preopenQueue.shift() as string);\n      }\n      this.emit(\"connect\");\n      resolveReady();\n    };\n    this.socket.onerror = (error) => {\n      this.emit(\"error\", error);\n    };\n\n    this.socket.onclose = (_event) => {\n      this._connected = false;\n      this.emit(\"disconnect\");\n      const wait = Math.min(\n        this.options.reconnectInterval *\n          Math.pow(this.options.reconnectDecay, this._reconnectAttempts),\n        this.options.maxReconnectInterval\n      );\n      setTimeout(() => {\n        this._reconnectAttempts += 1;\n        this._reconnect();\n      }, wait);\n    };\n  }\n\n  get connected(): boolean {\n    return this._connected;\n  }\n\n  send(message: string): void {\n    if (this.connected) this.socket.send(message);\n    else this.preopenQueue.push(message);\n  }\n\n  close(): void {\n    this.closed = true;\n    this.socket.close();\n  }\n}\n", "import * as T from \"../generated/types.js\";\nimport { EventType } from \"../generated/types.js\";\nimport * as RPC from \"../generated/jsonrpc.js\";\nimport { RawClient } from \"../generated/client.js\";\nimport { BaseTransport, Request } from \"yerpc\";\nimport { TinyEmitter } from \"@deltachat/tiny-emitter\";\n\ntype Events = { ALL: (accountId: number, event: EventType) => void } & {\n  [Property in EventType[\"kind\"]]: (\n    accountId: number,\n    event: Extract<EventType, { kind: Property }>\n  ) => void;\n};\n\ntype ContextEvents = { ALL: (event: EventType) => void } & {\n  [Property in EventType[\"kind\"]]: (\n    event: Extract<EventType, { kind: Property }>\n  ) => void;\n};\n\nexport type DcEvent = EventType;\nexport type DcEventType<T extends EventType[\"kind\"]> = Extract<\n  EventType,\n  { kind: T }\n>;\n\nexport class BaseDeltaChat<\n  Transport extends BaseTransport<any>\n> extends TinyEmitter<Events> {\n  rpc: RawClient;\n  account?: T.Account;\n  private contextEmitters: { [key: number]: TinyEmitter<ContextEvents> } = {};\n\n  //@ts-ignore\n  private eventTask: Promise<void>;\n\n  constructor(public transport: Transport, startEventLoop: boolean) {\n    super();\n    this.rpc = new RawClient(this.transport);\n    if (startEventLoop) {\n      this.eventTask = this.eventLoop();\n    }\n  }\n\n  async eventLoop(): Promise<void> {\n    while (true) {\n      const event = await this.rpc.getNextEvent();\n      //@ts-ignore\n      this.emit(event.event.kind, event.contextId, event.event);\n      this.emit(\"ALL\", event.contextId, event.event);\n\n      if (this.contextEmitters[event.contextId]) {\n        this.contextEmitters[event.contextId].emit(\n          event.event.kind,\n          //@ts-ignore\n          event.event as any\n        );\n        this.contextEmitters[event.contextId].emit(\"ALL\", event.event as any);\n      }\n    }\n  }\n\n  async listAccounts(): Promise<T.Account[]> {\n    return await this.rpc.getAllAccounts();\n  }\n\n  getContextEvents(account_id: number) {\n    if (this.contextEmitters[account_id]) {\n      return this.contextEmitters[account_id];\n    } else {\n      this.contextEmitters[account_id] = new TinyEmitter();\n      return this.contextEmitters[account_id];\n    }\n  }\n}\n\nexport class StdioDeltaChat extends BaseDeltaChat<StdioTransport> {\n  close() {}\n  constructor(input: any, output: any, startEventLoop: boolean) {\n    const transport = new StdioTransport(input, output);\n    super(transport, startEventLoop);\n  }\n}\n\nexport class StdioTransport extends BaseTransport {\n  constructor(public input: any, public output: any) {\n    super();\n\n    var buffer = \"\";\n    this.output.on(\"data\", (data: any) => {\n      buffer += data.toString();\n      while (buffer.includes(\"\\n\")) {\n        const n = buffer.indexOf(\"\\n\");\n        const line = buffer.substring(0, n);\n        const message = JSON.parse(line);\n        this._onmessage(message);\n        buffer = buffer.substring(n + 1);\n      }\n    });\n  }\n\n  _send(message: any): void {\n    const serialized = JSON.stringify(message);\n    this.input.write(serialized + \"\\n\");\n  }\n}\n", "// Generated!\n\nexport enum C {\n  DC_CERTCK_ACCEPT_INVALID = 2,\n  DC_CERTCK_ACCEPT_INVALID_CERTIFICATES = 3,\n  DC_CERTCK_AUTO = 0,\n  DC_CERTCK_STRICT = 1,\n  DC_CHAT_ID_ALLDONE_HINT = 7,\n  DC_CHAT_ID_ARCHIVED_LINK = 6,\n  DC_CHAT_ID_LAST_SPECIAL = 9,\n  DC_CHAT_ID_TRASH = 3,\n  DC_CHAT_TYPE_BROADCAST = 160,\n  DC_CHAT_TYPE_GROUP = 120,\n  DC_CHAT_TYPE_MAILINGLIST = 140,\n  DC_CHAT_TYPE_SINGLE = 100,\n  DC_CHAT_TYPE_UNDEFINED = 0,\n  DC_CONNECTIVITY_CONNECTED = 4000,\n  DC_CONNECTIVITY_CONNECTING = 2000,\n  DC_CONNECTIVITY_NOT_CONNECTED = 1000,\n  DC_CONNECTIVITY_WORKING = 3000,\n  DC_CONTACT_ID_DEVICE = 5,\n  DC_CONTACT_ID_INFO = 2,\n  DC_CONTACT_ID_LAST_SPECIAL = 9,\n  DC_CONTACT_ID_SELF = 1,\n  DC_GCL_ADD_ALLDONE_HINT = 4,\n  DC_GCL_ADD_SELF = 2,\n  DC_GCL_ARCHIVED_ONLY = 1,\n  DC_GCL_FOR_FORWARDING = 8,\n  DC_GCL_NO_SPECIALS = 2,\n  DC_GCL_VERIFIED_ONLY = 1,\n  DC_GCM_ADDDAYMARKER = 1,\n  DC_GCM_INFO_ONLY = 2,\n  DC_LP_AUTH_NORMAL = 4,\n  DC_LP_AUTH_OAUTH2 = 2,\n  DC_MEDIA_QUALITY_BALANCED = 0,\n  DC_MEDIA_QUALITY_WORSE = 1,\n  DC_MSG_ID_DAYMARKER = 9,\n  DC_MSG_ID_LAST_SPECIAL = 9,\n  DC_MSG_ID_MARKER1 = 1,\n  DC_PROVIDER_STATUS_BROKEN = 3,\n  DC_PROVIDER_STATUS_OK = 1,\n  DC_PROVIDER_STATUS_PREPARATION = 2,\n  DC_PUSH_CONNECTED = 2,\n  DC_PUSH_HEARTBEAT = 1,\n  DC_PUSH_NOT_CONNECTED = 0,\n  DC_SHOW_EMAILS_ACCEPTED_CONTACTS = 1,\n  DC_SHOW_EMAILS_ALL = 2,\n  DC_SHOW_EMAILS_OFF = 0,\n  DC_SOCKET_AUTO = 0,\n  DC_SOCKET_PLAIN = 3,\n  DC_SOCKET_SSL = 1,\n  DC_SOCKET_STARTTLS = 2,\n  DC_STATE_IN_FRESH = 10,\n  DC_STATE_IN_NOTICED = 13,\n  DC_STATE_IN_SEEN = 16,\n  DC_STATE_OUT_DELIVERED = 26,\n  DC_STATE_OUT_DRAFT = 19,\n  DC_STATE_OUT_FAILED = 24,\n  DC_STATE_OUT_MDN_RCVD = 28,\n  DC_STATE_OUT_PENDING = 20,\n  DC_STATE_OUT_PREPARING = 18,\n  DC_STATE_UNDEFINED = 0,\n  DC_STR_AC_SETUP_MSG_BODY = 43,\n  DC_STR_AC_SETUP_MSG_SUBJECT = 42,\n  DC_STR_ADD_MEMBER_BY_OTHER = 129,\n  DC_STR_ADD_MEMBER_BY_YOU = 128,\n  DC_STR_AEAP_ADDR_CHANGED = 122,\n  DC_STR_AEAP_EXPLANATION_AND_LINK = 123,\n  DC_STR_ARCHIVEDCHATS = 40,\n  DC_STR_AUDIO = 11,\n  DC_STR_BACKUP_TRANSFER_MSG_BODY = 163,\n  DC_STR_BACKUP_TRANSFER_QR = 162,\n  DC_STR_BAD_TIME_MSG_BODY = 85,\n  DC_STR_BROADCAST_LIST = 115,\n  DC_STR_CANNOT_LOGIN = 60,\n  DC_STR_CANTDECRYPT_MSG_BODY = 29,\n  DC_STR_CHAT_PROTECTION_DISABLED = 171,\n  DC_STR_CHAT_PROTECTION_ENABLED = 170,\n  DC_STR_CONFIGURATION_FAILED = 84,\n  DC_STR_CONNECTED = 107,\n  DC_STR_CONNTECTING = 108,\n  DC_STR_CONTACT = 200,\n  DC_STR_CONTACT_NOT_VERIFIED = 36,\n  DC_STR_CONTACT_SETUP_CHANGED = 37,\n  DC_STR_CONTACT_VERIFIED = 35,\n  DC_STR_DEVICE_MESSAGES = 68,\n  DC_STR_DEVICE_MESSAGES_HINT = 70,\n  DC_STR_DOWNLOAD_AVAILABILITY = 100,\n  DC_STR_DRAFT = 3,\n  DC_STR_E2E_AVAILABLE = 25,\n  DC_STR_E2E_PREFERRED = 34,\n  DC_STR_ENCRYPTEDMSG = 24,\n  DC_STR_ENCR_NONE = 28,\n  DC_STR_ENCR_TRANSP = 27,\n  DC_STR_EPHEMERAL_DAY = 79,\n  DC_STR_EPHEMERAL_DAYS = 95,\n  DC_STR_EPHEMERAL_DISABLED = 75,\n  DC_STR_EPHEMERAL_FOUR_WEEKS = 81,\n  DC_STR_EPHEMERAL_HOUR = 78,\n  DC_STR_EPHEMERAL_HOURS = 94,\n  DC_STR_EPHEMERAL_MINUTE = 77,\n  DC_STR_EPHEMERAL_MINUTES = 93,\n  DC_STR_EPHEMERAL_SECONDS = 76,\n  DC_STR_EPHEMERAL_TIMER_1_DAY_BY_OTHER = 147,\n  DC_STR_EPHEMERAL_TIMER_1_DAY_BY_YOU = 146,\n  DC_STR_EPHEMERAL_TIMER_1_HOUR_BY_OTHER = 145,\n  DC_STR_EPHEMERAL_TIMER_1_HOUR_BY_YOU = 144,\n  DC_STR_EPHEMERAL_TIMER_1_MINUTE_BY_OTHER = 143,\n  DC_STR_EPHEMERAL_TIMER_1_MINUTE_BY_YOU = 142,\n  DC_STR_EPHEMERAL_TIMER_1_WEEK_BY_OTHER = 149,\n  DC_STR_EPHEMERAL_TIMER_1_WEEK_BY_YOU = 148,\n  DC_STR_EPHEMERAL_TIMER_DAYS_BY_OTHER = 155,\n  DC_STR_EPHEMERAL_TIMER_DAYS_BY_YOU = 154,\n  DC_STR_EPHEMERAL_TIMER_DISABLED_BY_OTHER = 139,\n  DC_STR_EPHEMERAL_TIMER_DISABLED_BY_YOU = 138,\n  DC_STR_EPHEMERAL_TIMER_HOURS_BY_OTHER = 153,\n  DC_STR_EPHEMERAL_TIMER_HOURS_BY_YOU = 152,\n  DC_STR_EPHEMERAL_TIMER_MINUTES_BY_OTHER = 151,\n  DC_STR_EPHEMERAL_TIMER_MINUTES_BY_YOU = 150,\n  DC_STR_EPHEMERAL_TIMER_SECONDS_BY_OTHER = 141,\n  DC_STR_EPHEMERAL_TIMER_SECONDS_BY_YOU = 140,\n  DC_STR_EPHEMERAL_TIMER_WEEKS_BY_OTHER = 157,\n  DC_STR_EPHEMERAL_TIMER_WEEKS_BY_YOU = 156,\n  DC_STR_EPHEMERAL_WEEK = 80,\n  DC_STR_EPHEMERAL_WEEKS = 96,\n  DC_STR_ERROR = 112,\n  DC_STR_ERROR_NO_NETWORK = 87,\n  DC_STR_FAILED_SENDING_TO = 74,\n  DC_STR_FILE = 12,\n  DC_STR_FINGERPRINTS = 30,\n  DC_STR_FORWARDED = 97,\n  DC_STR_GIF = 23,\n  DC_STR_GROUP_IMAGE_CHANGED_BY_OTHER = 127,\n  DC_STR_GROUP_IMAGE_CHANGED_BY_YOU = 126,\n  DC_STR_GROUP_IMAGE_DELETED_BY_OTHER = 135,\n  DC_STR_GROUP_IMAGE_DELETED_BY_YOU = 134,\n  DC_STR_GROUP_LEFT_BY_OTHER = 133,\n  DC_STR_GROUP_LEFT_BY_YOU = 132,\n  DC_STR_GROUP_NAME_CHANGED_BY_OTHER = 125,\n  DC_STR_GROUP_NAME_CHANGED_BY_YOU = 124,\n  DC_STR_IMAGE = 9,\n  DC_STR_INCOMING_MESSAGES = 103,\n  DC_STR_INVALID_UNENCRYPTED_MAIL = 174,\n  DC_STR_LAST_MSG_SENT_SUCCESSFULLY = 111,\n  DC_STR_LOCATION = 66,\n  DC_STR_LOCATION_ENABLED_BY_OTHER = 137,\n  DC_STR_LOCATION_ENABLED_BY_YOU = 136,\n  DC_STR_MESSAGES = 114,\n  DC_STR_MESSAGE_ADD_MEMBER = 173,\n  DC_STR_MSGACTIONBYME = 63,\n  DC_STR_MSGACTIONBYUSER = 62,\n  DC_STR_MSGADDMEMBER = 17,\n  DC_STR_MSGDELMEMBER = 18,\n  DC_STR_MSGGROUPLEFT = 19,\n  DC_STR_MSGGRPIMGCHANGED = 16,\n  DC_STR_MSGGRPIMGDELETED = 33,\n  DC_STR_MSGGRPNAME = 15,\n  DC_STR_MSGLOCATIONDISABLED = 65,\n  DC_STR_MSGLOCATIONENABLED = 64,\n  DC_STR_NEW_GROUP_SEND_FIRST_MESSAGE = 172,\n  DC_STR_NOMESSAGES = 1,\n  DC_STR_NOT_CONNECTED = 121,\n  DC_STR_NOT_SUPPORTED_BY_PROVIDER = 113,\n  DC_STR_ONE_MOMENT = 106,\n  DC_STR_OUTGOING_MESSAGES = 104,\n  DC_STR_PARTIAL_DOWNLOAD_MSG_BODY = 99,\n  DC_STR_PART_OF_TOTAL_USED = 116,\n  DC_STR_QUOTA_EXCEEDING_MSG_BODY = 98,\n  DC_STR_REACTED_BY = 177,\n  DC_STR_READRCPT = 31,\n  DC_STR_READRCPT_MAILBODY = 32,\n  DC_STR_REMOVE_MEMBER_BY_OTHER = 131,\n  DC_STR_REMOVE_MEMBER_BY_YOU = 130,\n  DC_STR_REPLY_NOUN = 90,\n  DC_STR_SAVED_MESSAGES = 69,\n  DC_STR_SECUREJOIN_TAKES_LONGER = 192,\n  DC_STR_SECUREJOIN_WAIT = 190,\n  DC_STR_SECUREJOIN_WAIT_TIMEOUT = 191,\n  DC_STR_SECURE_JOIN_GROUP_QR_DESC = 120,\n  DC_STR_SECURE_JOIN_REPLIES = 118,\n  DC_STR_SECURE_JOIN_STARTED = 117,\n  DC_STR_SELF = 2,\n  DC_STR_SELF_DELETED_MSG_BODY = 91,\n  DC_STR_SENDING = 110,\n  DC_STR_SERVER_TURNED_OFF = 92,\n  DC_STR_SETUP_CONTACT_QR_DESC = 119,\n  DC_STR_STICKER = 67,\n  DC_STR_STORAGE_ON_DOMAIN = 105,\n  DC_STR_SUBJECT_FOR_NEW_CONTACT = 73,\n  DC_STR_SYNC_MSG_BODY = 102,\n  DC_STR_SYNC_MSG_SUBJECT = 101,\n  DC_STR_UNKNOWN_SENDER_FOR_CHAT = 72,\n  DC_STR_UPDATE_REMINDER_MSG_BODY = 86,\n  DC_STR_UPDATING = 109,\n  DC_STR_VIDEO = 10,\n  DC_STR_VIDEOCHAT_INVITATION = 82,\n  DC_STR_VIDEOCHAT_INVITE_MSG_BODY = 83,\n  DC_STR_VOICEMESSAGE = 7,\n  DC_STR_WELCOME_MESSAGE = 71,\n  DC_STR_YOU_REACTED = 176,\n  DC_TEXT1_DRAFT = 1,\n  DC_TEXT1_SELF = 3,\n  DC_TEXT1_USERNAME = 2,\n  DC_VIDEOCHATTYPE_BASICWEBRTC = 1,\n  DC_VIDEOCHATTYPE_JITSI = 2,\n  DC_VIDEOCHATTYPE_UNKNOWN = 0,\n}\n", "export function parseThemeMetaData(rawTheme: string): {\n  name: string\n  description: string\n} {\n  const meta_data_block =\n    /.theme-meta ?{([^]*)}/gm.exec(rawTheme)?.[1].trim() || ''\n\n  const regex = /--(\\w*): ?['\"]([^]*?)['\"];?/gi\n\n  const meta: { [key: string]: string } = {}\n\n  let last_result: any = true\n\n  while (last_result) {\n    last_result = regex.exec(meta_data_block)\n    if (last_result) {\n      meta[last_result[1]] = last_result[2]\n    }\n  }\n\n  // check if name and description are defined\n  if (!meta.name || !meta.description) {\n    throw new Error(\n      'The meta variables meta.name and meta.description must be defined'\n    )\n  }\n\n  return <any>meta\n}\n\nexport const HIDDEN_THEME_PREFIX = 'dev_'\n", "// This needs to be injected / imported before the frontend script\n\nimport {\n  AutostartState,\n  DcNotification,\n  DcOpenWebxdcParameters,\n  DesktopSettingsType,\n  RC_Config,\n  RuntimeInfo,\n  RuntimeOpenDialogOptions,\n  Theme,\n} from '@deltachat-desktop/shared/shared-types.js'\nimport '@deltachat-desktop/shared/global.d.ts'\n\nimport { LocaleData } from '@deltachat-desktop/shared/localize.js'\nimport {\n  MediaAccessStatus,\n  MediaType,\n  Runtime,\n} from '@deltachat-desktop/runtime-interface'\nimport { BaseDeltaChat, yerpc } from '@deltachat/jsonrpc-client'\n\nimport type { getLogger as getLoggerFunction } from '@deltachat-desktop/shared/logger.js'\nimport type { setLogHandler as setLogHandlerFunction } from '@deltachat-desktop/shared/logger.js'\nimport {\n  HIDDEN_THEME_PREFIX,\n  parseThemeMetaData,\n} from '@deltachat-desktop/shared/themes.js'\n\nimport { MessageToBackend } from '../src/runtime-ws-protocol.js'\n\nconst { WebsocketTransport } = yerpc\n\nlet logJsonrpcConnection = false\n\nclass BrowserTransport extends WebsocketTransport {\n  constructor(private callCounterFunction: (label: string) => void) {\n    super('wss://localhost:3000/ws/dc')\n  }\n\n  protected _onmessage(message: yerpc.Message): void {\n    if (\n      (message as any)['method'] === 'error_other_client_stole_dc_connection'\n    ) {\n      alert(\n        'error other client stole dc connection.\\nonly use deltachat web in one browser at a time.\\nreload to steal connection back.'\n      )\n      throw new Error(\n        'connection inactive: error other client stole dc connection, please reload page'\n      )\n    }\n    if (logJsonrpcConnection) {\n      /* ignore-console-log */\n      console.debug('%c\u25BC %c[JSONRPC]', 'color: red', 'color:grey', message)\n    }\n    super._onmessage(message)\n  }\n\n  _send(message: yerpc.Message): void {\n    super._send(message)\n    if (logJsonrpcConnection) {\n      /* ignore-console-log */\n      console.debug('%c\u25B2 %c[JSONRPC]', 'color: green', 'color:grey', message)\n      if ((message as any)['method']) {\n        this.callCounterFunction((message as any).method)\n        this.callCounterFunction('total')\n      }\n    }\n  }\n}\n\nclass BrowserDeltachat extends BaseDeltaChat<BrowserTransport> {\n  close() {\n    /** noop */\n  }\n  constructor(callCounterFunction: (label: string) => void) {\n    super(new BrowserTransport(callCounterFunction), true)\n  }\n}\n\nclass BrowserRuntime implements Runtime {\n  socket: WebSocket\n  private rc_config: RC_Config | null = null\n  constructor() {\n    this.socket = new WebSocket('wss://localhost:3000/ws/backend')\n\n    this.socket.addEventListener('open', () => {\n      /* ignore-console-log */\n      console.log('WebSocket connection opened')\n    })\n\n    this.socket.addEventListener('message', event => {\n      /* ignore-console-log */\n      console.log('Received message from server:', event.data)\n    })\n\n    this.socket.addEventListener('close', () => {\n      /* ignore-console-log */\n      console.log('WebSocket connection closed')\n    })\n\n    this.socket.addEventListener('error', event => {\n      /* ignore-console-log */\n      console.error('WebSocket error:', event)\n    })\n  }\n\n  sendToBackendOverWS(message: MessageToBackend.AllTypes) {\n    if (this.socket.readyState != this.socket.OPEN) {\n      /* ignore-console-log */\n      console.warn(\n        'sendToBackendOverWS can not send message to backend because websocket is not open'\n      )\n    } else {\n      try {\n        this.socket.send(JSON.stringify(message))\n      } catch (error) {\n        /* ignore-console-log */\n        console.warn(\n          'sendToBackendOverWS failed to send message to backend over websocket'\n        )\n      }\n    }\n  }\n\n  // #region event callbacks from runtime backend\n\n  onWebxdcSendToChat:\n    | ((\n        file: { file_name: string; file_content: string } | null,\n        text: string | null\n      ) => void)\n    | undefined\n  onThemeUpdate: (() => void) | undefined //!!!TODO!!!\n\n  // not used in browser, there is no menu to trigger these\n  onChooseLanguage: ((locale: string) => Promise<void>) | undefined\n  onShowDialog:\n    | ((kind: 'about' | 'keybindings' | 'settings') => void)\n    | undefined\n\n  // not used in browser - other reasons\n  onResumeFromSleep: (() => void) | undefined\n  onOpenQrUrl: ((url: string) => void) | undefined\n  onToggleNotifications: (() => void) | undefined\n\n  // #endregion\n\n  openMapsWebxdc(_accountId: number, _chatId?: number | undefined): void {\n    throw new Error('Method not implemented.')\n  }\n\n  emitUIFullyReady(): void {\n    this.sendToBackendOverWS({ type: 'UIReadyFrontendReady' })\n  }\n  onDragFileOut(_file: string): void {\n    // Browser can not implement this\n    return\n  }\n  isDroppedFileFromOutside(_file: File): boolean {\n    return true // Browser does not support dragging files out, so can only be from outside\n  }\n  emitUIReady(): void {\n    this.sendToBackendOverWS({ type: 'UIReady' })\n  }\n  createDeltaChatConnection(\n    callCounterFunction: (label: string) => void\n  ): BaseDeltaChat<any> {\n    return new BrowserDeltachat(callCounterFunction)\n  }\n  openMessageHTML(\n    _accountId: number,\n    _message_id: number,\n    _isContactRequest: boolean,\n    _subject: string,\n    _sender: string,\n    _receiveTime: string,\n    _content: string\n  ): void {\n    throw new Error('Method not implemented.')\n  }\n  notifyWebxdcStatusUpdate(_accountId: number, _instanceId: number): void {\n    this.log.critical('Method not implemented.')\n  }\n  notifyWebxdcRealtimeData(\n    _accountId: number,\n    _instanceId: number,\n    _payload: number[]\n  ): void {\n    this.log.critical('Method not implemented.')\n  }\n  notifyWebxdcMessageChanged(_accountId: number, _instanceId: number): void {\n    this.log.critical('Method not implemented.')\n  }\n  notifyWebxdcInstanceDeleted(_accountId: number, _instanceId: number): void {\n    this.log.critical('Method not implemented.')\n  }\n  async saveBackgroundImage(\n    file: string,\n    isDefaultPicture: boolean\n  ): Promise<string> {\n    const result = await fetch('/backend-api/saveBackgroundImage', {\n      body: JSON.stringify({ file, isDefaultPicture }),\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n      },\n    })\n    if (!result.ok) {\n      this.log.error('saveBackgroundImage failed', result)\n      throw new Error('saveBackgroundImage failed: ' + result.statusText)\n    }\n    return (await result.json()).result\n  }\n  async getLocaleData(locale?: string | undefined): Promise<LocaleData> {\n    const messagesEnglish = await (await fetch('/locales/en.json')).json()\n    const untranslated = await (\n      await fetch('/locales/_untranslated_en.json')\n    ).json()\n\n    if (!locale) {\n      return { locale: 'en', messages: { ...messagesEnglish, ...untranslated } }\n    }\n\n    let localeMessages: LocaleData['messages']\n    try {\n      localeMessages = await (await fetch(`/locales/${locale}.json`)).json()\n    } catch (error1) {\n      // We couldn't load the file for the locale but it's a dialect. Try to fall\n      // back to the main language (example: de-CH -> de)\n      try {\n        if (locale.indexOf('-') !== -1) {\n          const base_locale = (locale = locale.split('-')[0])\n\n          localeMessages = await (\n            await fetch(`/locales/${base_locale}.json`)\n          ).json()\n        } else {\n          throw new Error(\n            'language load failed, even alternative of base language failed.'\n          )\n        }\n      } catch (error2) {\n        this.log.error(\n          `Could not load messages for ${locale}, falling back to english`,\n          error1,\n          error2\n        )\n        locale = 'en'\n        localeMessages = messagesEnglish\n      }\n    }\n    return { locale: 'en', messages: { ...localeMessages, ...untranslated } }\n  }\n  setLocale(_locale: string): Promise<void> {\n    throw new Error('Method not implemented.')\n  }\n  async setDesktopSetting(\n    key: keyof DesktopSettingsType,\n    value: string | number | boolean | undefined\n  ): Promise<void> {\n    // if key is notifications and new value is on/true, then ask browser for permission\n    if (key == 'notifications' && Boolean(value)) {\n      await this.askBrowserForNotificationPermission()\n    }\n\n    const request = await fetch(`/backend-api/config/${key}`, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n      },\n      body: JSON.stringify({ new_value: value }),\n    })\n    if (!request.ok) {\n      throw new Error('setDesktopSettings request failed')\n    }\n  }\n  async getAvailableThemes(): Promise<Theme[]> {\n    return (await fetch('/themes.json')).json()\n  }\n  async getActiveTheme(): Promise<{ theme: Theme; data: string } | null> {\n    const address = (await this.getDesktopSettings()).activeTheme\n    let [location, id] = address.split(':')\n    if (location === 'system') {\n      location = 'dc'\n      id = window.matchMedia('(prefers-color-scheme: dark)').matches\n        ? 'dark'\n        : 'light'\n    }\n    if (location !== 'dc') {\n      throw new Error('only dc themes are implmented in the browser edition')\n    }\n\n    const realPath = `/themes/${id}.css`\n    const theme_file_request = await fetch(realPath)\n    if (!theme_file_request.ok) {\n      throw new Error('error loading theme: ' + theme_file_request.statusText)\n    }\n    const data = await theme_file_request.text()\n    const metadata = parseThemeMetaData(data)\n\n    return {\n      theme: {\n        address,\n        description: metadata.description,\n        name: metadata.name,\n        is_prototype: id.startsWith(HIDDEN_THEME_PREFIX),\n      },\n      data,\n    }\n  }\n  async clearWebxdcDOMStorage(_accountId: number): Promise<void> {\n    // not applicable in browser\n    this.log.warn('clearWebxdcDOMStorage method does not exist in browser.')\n  }\n  getWebxdcDiskUsage(_accountId: number): Promise<{\n    total_size: number\n    data_size: number\n  }> {\n    // not applicable in browser\n    throw new Error('getWebxdcDiskUsage method does not exist in browser.')\n  }\n  async writeTempFileFromBase64(\n    name: string,\n    content: string\n  ): Promise<string> {\n    return (\n      await (\n        await fetch(`/backend-api/uploadTempFileB64/${name}`, {\n          method: 'POST',\n          body: content,\n        })\n      ).json()\n    ).path\n  }\n  async writeTempFile(name: string, content: string): Promise<string> {\n    return (\n      await (\n        await fetch(`/backend-api/uploadTempFile/${name}`, {\n          method: 'POST',\n          body: content,\n        })\n      ).json()\n    ).path\n  }\n  async copyFileToInternalTmpDir(\n    _fileName: string,\n    _sourcePath: string\n  ): Promise<string> {\n    throw new Error('Method not implemented')\n  }\n  async removeTempFile(name: string): Promise<void> {\n    await fetch(`/backend-api/removeTempFile`, {\n      method: 'POST',\n      body: name,\n    })\n  }\n\n  activeNotifications: {\n    [accountId: number]: { [chatId: number]: Notification[] }\n  } = {}\n  notificationCB: (data: {\n    accountId: number\n    chatId: number\n    msgId: number\n  }) => void = () => {\n    this.log.critical('notification click handler not initialized yet')\n  }\n\n  setNotificationCallback(\n    cb: (data: { accountId: number; chatId: number; msgId: number }) => void\n  ): void {\n    this.notificationCB = cb\n  }\n  async showNotification(data: DcNotification): Promise<void> {\n    if (Notification.permission != 'granted') {\n      this.log.warn(\n        \"failed to showNotification: we don't have permission to send notifications\"\n      )\n      return\n    }\n    const {\n      accountId,\n      chatId,\n      body,\n      title,\n      icon: notificationIcon,\n      messageId,\n    } = data\n    this.log.debug('showNotification', { accountId, chatId, messageId })\n\n    // TODO real timestamp (why? because we can! ;)\n\n    let icon = (() => {\n      const url = new URL(location.origin)\n      url.pathname = 'images/deltachat.png'\n      return url.toString()\n    })()\n\n    if (notificationIcon) {\n      // we need to pass the image/icon as dataurl, otherwise the browser has no permission to access it.\n      // IDEA: alternatively we could make another route that exposes the file with a random hash without authentification?\n      // Concern: Also the current method could run into size limits because it loads the whole image, which can be large? like high ram usage in browser?\n      try {\n        const response = await fetch(\n          notificationIcon.startsWith('data:')\n            ? notificationIcon\n            : this.transformBlobURL(notificationIcon)\n        )\n        if (!response.ok) {\n          throw new Error('request failed: code' + response.status)\n        }\n        const blob = await response.blob()\n        icon = await new Promise((resolve, reject) => {\n          const reader = new FileReader()\n          reader.onloadend = () => {\n            resolve(reader.result as any)\n          }\n          reader.onabort = reject\n          reader.onerror = reject\n          reader.readAsDataURL(blob)\n        })\n      } catch (error) {\n        this.log.warn('failed to load thumbnail for notification', error)\n      }\n    }\n\n    this.log.info('notify-icon', { icon }) // todo rm\n    const notification = new Notification(title, {\n      body,\n      icon,\n      tag: `${accountId}.${chatId}.${messageId}`,\n    })\n\n    notification.onclick = this.notificationCB.bind(this, {\n      accountId,\n      chatId,\n      msgId: messageId,\n    })\n\n    if (!this.activeNotifications[accountId]) {\n      this.activeNotifications[accountId] = {}\n    }\n\n    if (this.activeNotifications[accountId][chatId]) {\n      this.activeNotifications[accountId][chatId].push(notification)\n    } else {\n      this.activeNotifications[accountId][chatId] = [notification]\n    }\n  }\n  clearAllNotifications(): void {\n    for (const accountId of Object.keys(this.activeNotifications)) {\n      if (!Number.isNaN(Number(accountId))) {\n        for (const chatId of Object.keys(\n          this.activeNotifications[Number(accountId)]\n        )) {\n          if (!Number.isNaN(Number(chatId))) {\n            this.clearNotifications(Number(accountId), Number(chatId))\n          }\n        }\n      }\n    }\n  }\n  clearNotifications(accountId: number, chatId: number): void {\n    this.log.debug('clearNotificationsForChat', {\n      chatId,\n      notifications: this.activeNotifications,\n    })\n    if (this.activeNotifications[accountId]?.[chatId]) {\n      for (const notify of this.activeNotifications[accountId][chatId]) {\n        notify.close()\n      }\n      delete this.activeNotifications[accountId][chatId]\n    }\n    this.log.debug('after cleared Notifications', {\n      chatId,\n      notifications: this.activeNotifications,\n    })\n  }\n  setBadgeCounter(value: number): void {\n    document.title = `DeltaChat${value ? `(${value})` : ''}`\n  }\n  deleteWebxdcAccountData(_accountId: number): Promise<void> {\n    // not applicable in browser\n    this.log.warn('deleteWebxdcAccountData method does not exist in browser.')\n    return Promise.resolve()\n  }\n  closeAllWebxdcInstances(): void {\n    this.log.critical('Method not implemented.')\n  }\n  restartApp(): void {\n    this.log.critical('Method not implemented.')\n  }\n  private runtime_info: RuntimeInfo | null = null\n  getRuntimeInfo(): RuntimeInfo {\n    if (this.runtime_info === null) {\n      throw new Error('this.runtime_info is not set')\n    }\n    return this.runtime_info\n  }\n  async getDesktopSettings(): Promise<DesktopSettingsType> {\n    const request = await fetch('/backend-api/config')\n    if (!request.ok) {\n      throw new Error('getDesktopSettings request failed')\n    }\n    const config = await request.json()\n    if (config.locale === null) {\n      config.locale = navigator.language\n    }\n    return config\n  }\n  getWebxdcIconURL(_accountId: number, _msgId: number): string {\n    this.log.critical('getWebxdcIconURL Method not implemented.')\n    return 'not-implemented'\n  }\n  openWebxdc(_msgId: number, _params: DcOpenWebxdcParameters): void {\n    throw new Error('Method not implemented.')\n  }\n  async openPath(path: string): Promise<string> {\n    if (path.includes('dc.db-blobs')) {\n      window.open(this.transformBlobURL(path), '_blank')?.focus()\n      return ''\n    } else {\n      throw new Error(\n        'Browser does not support opening urls outside of blob directory'\n      )\n    }\n  }\n  async getAppPath(_name: string): Promise<string> {\n    this.log.critical('Method not implemented.')\n    return 'not-implemented'\n  }\n  async downloadFile(pathToSource: string, filename: string): Promise<void> {\n    if (pathToSource.includes('dc.db-blobs')) {\n      window\n        .open(\n          this.transformBlobURL(pathToSource) +\n            '?download_with_filename=' +\n            encodeURIComponent(filename),\n          '_blank'\n        )\n        ?.focus()\n    } else {\n      throw new Error(\n        'Browser does not support opening urls outside of blob directory'\n      )\n    }\n  }\n  readClipboardText(): Promise<string> {\n    return navigator.clipboard.readText()\n  }\n  async readClipboardImage(): Promise<string | null> {\n    try {\n      const clipboardItems = await navigator.clipboard.read()\n      for (const clipboardItem of clipboardItems) {\n        for (const type of clipboardItem.types) {\n          if (type.startsWith('image')) {\n            const blob = await clipboardItem.getType(type)\n            return await new Promise((resolve, reject) => {\n              const reader = new FileReader()\n              reader.onloadend = () => {\n                resolve(reader.result as any)\n              }\n              reader.onabort = reject\n              reader.onerror = reject\n              reader.readAsDataURL(blob)\n            })\n          }\n        }\n      }\n    } catch (err) {\n      this.log.error('error in readClipboardImage', err)\n    }\n    return null\n  }\n  writeClipboardText(text: string): Promise<void> {\n    return navigator.clipboard.writeText(text)\n  }\n  async writeClipboardImage(path: string): Promise<void> {\n    try {\n      const imgURL = this.transformBlobURL(path)\n      const data = await fetch(imgURL)\n      let blob = await data.blob()\n      if (!blob.type.startsWith('image')) {\n        throw new Error('Not an image mimetype:' + blob.type)\n      }\n      if (blob.type !== 'image/png') {\n        const img = new Image()\n        const blobPromise = new Promise<Blob>((resolve, reject) => {\n          img.onload = async () => {\n            try {\n              const canvas = new OffscreenCanvas(\n                img.naturalWidth,\n                img.naturalHeight\n              )\n              const ctx = canvas.getContext('2d')\n              if (!ctx) {\n                throw new Error('canvas context creation error')\n              }\n              ctx.fillRect(0, 0, canvas.width, canvas.height)\n              ctx.drawImage(img, 0, 0)\n              resolve(await canvas.convertToBlob())\n            } catch (error) {\n              reject(error)\n            }\n          }\n          img.onerror = reject\n          img.onabort = reject\n        })\n        img.src = imgURL // load the image\n        blob = await blobPromise\n      }\n      await navigator.clipboard.write([\n        new ClipboardItem({\n          [blob.type]: blob,\n        }),\n      ])\n      this.log.debug('Fetched image copied.')\n    } catch (err) {\n      this.log.error('error in writeClipboardImage', err)\n      throw err\n    }\n  }\n\n  transformBlobURL(blob_path: string): string {\n    const matches = blob_path.match(/.*(:?\\\\|\\/)(.+?)\\1dc.db-blobs\\1(.*)/)\n    // this.log.info({ transformBlobURL: blob_path, matches })\n    if (matches) {\n      return `/blobs/${matches[2]}/${matches[3]}`\n    }\n    if (blob_path !== '') {\n      this.log.error('transformBlobURL wrong url format', blob_path)\n    } else {\n      this.log.debug('transformBlobURL called with empty string for blob_path')\n    }\n    return ''\n  }\n  transformStickerURL(_sticker_path: string): string {\n    throw new Error('sticker picker is not implemented yet for browser')\n  }\n  async showOpenFileDialog(\n    options: RuntimeOpenDialogOptions\n  ): Promise<string[]> {\n    const extstring = options.filters\n      ?.map(filter => filter.extensions)\n      .reduce((p, c) => c.concat(p))\n      .map(ext => `.${ext}`)\n      .join()\n    return new Promise((resolve, reject) => {\n      const input = document.createElement('input')\n      input.type = 'file'\n      input.accept = extstring || ''\n      if (options.properties.includes('multiSelections')) {\n        input.multiple = true\n      }\n      input.onchange = async () => {\n        if (input.files != null) {\n          const uploads: Promise<string>[] = [...input.files].map(file =>\n            fetch(`/backend-api/uploadTempFile/${file.name}`, {\n              method: 'POST',\n              body: file,\n            })\n              .then(r => r.json())\n              .then(r => r.path)\n          )\n          const results = await Promise.allSettled(uploads)\n          this.log.debug('showOpenFileDialog upload - results', results)\n          const uploadedFiles = results\n            .filter(result => result.status == 'fulfilled')\n            .map(result => result.value)\n          const rejectedPromise = results.find(\n            result => result.status == 'rejected'\n          )\n          if (rejectedPromise) {\n            this.log.warn(\n              'some file failed to upload with error, removing other files now:',\n              rejectedPromise.reason\n            )\n            // remove other files on error\n            uploadedFiles.forEach(path => {\n              this.removeTempFile(path)\n            })\n            reject(rejectedPromise.reason)\n          } else {\n            resolve(uploadedFiles)\n          }\n        } else {\n          resolve([])\n        }\n      }\n\n      input.click()\n    })\n  }\n\n  openLink(link: string): void {\n    window.open(link, '_blank')?.focus()\n  }\n\n  private log!: ReturnType<typeof getLoggerFunction>\n  async initialize(\n    setLogHandler: typeof setLogHandlerFunction,\n    getLogger: typeof getLoggerFunction\n  ): Promise<void> {\n    this.log = getLogger('runtime/browser')\n\n    const [RCConfigRequest, RuntimeInfoRequest] = await Promise.all([\n      fetch('/backend-api/rc_config'),\n      fetch('/backend-api/runtime_info'),\n    ])\n\n    if (!RCConfigRequest.ok || !RuntimeInfoRequest.ok) {\n      throw new Error(\n        'initialisation failed, look into network tab for more into'\n      )\n    }\n\n    const config: RC_Config = (this.rc_config = await RCConfigRequest.json())\n\n    if (config['log-debug']) {\n      logJsonrpcConnection = true\n    }\n\n    /* ignore-console-log */\n    console.info('RC_Config', config)\n    this.runtime_info = await RuntimeInfoRequest.json()\n\n    setLogHandler((channel, level, stack_trace, ...args) => {\n      this.sendToBackendOverWS({\n        type: 'log',\n        data: [channel, level, stack_trace, ...args],\n      })\n    }, config)\n\n    this.askBrowserForNotificationPermission()\n  }\n\n  async askBrowserForNotificationPermission() {\n    if ('Notification' in window && Notification.permission !== 'granted') {\n      const result = await Notification.requestPermission()\n      this.log.debug('Notification.requestPermission', { result })\n    }\n  }\n\n  getRC_Config(): RC_Config {\n    if (this.rc_config === null) {\n      throw new Error('this.rc_config is not set')\n    }\n    return this.rc_config\n  }\n  async openHelpWindow(anchor?: string): Promise<void> {\n    const curLang = window.localeData.locale\n    const response = await fetch(`/help_exists/${curLang}`)\n\n    const anchorPath = anchor ? '#' + anchor : ''\n    if (response.ok) {\n      window.open(`/help/${curLang}/help.html${anchorPath}`, '_blank')?.focus()\n    } else {\n      window.open('/help/en/help.html' + anchorPath, '_blank')?.focus()\n    }\n  }\n  openLogFile(): void {\n    throw new Error('Method not implemented.')\n  }\n  getCurrentLogLocation(): string {\n    return 'not implemented.'\n  }\n  reloadWebContent(): void {\n    window.location.reload()\n  }\n  getConfigPath(): string {\n    this.log.warn('getConfigPath method does not exist in browser.')\n    return ''\n  }\n  getAutostartState(): Promise<AutostartState> {\n    return Promise.resolve({\n      isSupported: false,\n      isRegistered: false,\n    })\n  }\n  async checkMediaAccess(mediaType: MediaType): Promise<MediaAccessStatus> {\n    return navigator.permissions\n      .query({ name: mediaType as PermissionName })\n      .then(result => {\n        if (result.state === 'granted') {\n          return 'granted'\n        } else if (result.state === 'prompt') {\n          return 'not-determined'\n        } else if (result.state === 'denied') {\n          return 'denied'\n        }\n        return 'unknown'\n      })\n  }\n  askForMediaAccess(mediaType: MediaType): Promise<boolean> {\n    if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {\n      this.log.error('askForMediaAccess failed: no mediaDevices')\n      return Promise.resolve(false)\n    } else if (mediaType !== 'microphone') {\n      return navigator.mediaDevices.getUserMedia({ audio: true }).then(\n        stream => {\n          stream.getTracks().forEach(track => track.stop())\n          return true\n        },\n        err => {\n          this.log.error('askForMediaAccess \"microphone\" failed', err)\n          return false\n        }\n      )\n    } else {\n      this.log.error(\n        `askForMediaAccess failed: mediaType \"${mediaType}\" not implemented`\n      )\n      return Promise.resolve(false)\n    }\n  }\n}\n\n;(window as any).r = new BrowserRuntime()\n"],
  "mappings": "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",
  "names": ["require_browser", "__commonJSMin", "exports", "module", "ws", "require_tiny_emitter", "__commonJSMin", "exports", "module", "E", "__name", "name", "callback", "ctx", "e", "self", "listener", "data", "evtArr", "i", "len", "error", "evts", "liveEvents", "RawClient", "__name", "_transport", "delay", "email", "pathToDb", "accountId", "id", "timeoutInSeconds", "path", "key", "value", "config", "qrContent", "keys", "strings", "param", "qr", "addr", "passphrase", "chatId", "fromServer", "seconds", "messageId", "setupCode", "listFlags", "queryString", "queryContactId", "entries", "contactId", "name", "protect", "newName", "imagePath", "visibility", "timer", "label", "msg", "duration", "msgIds", "infoOnly", "addDaymarker", "msgId", "messageIds", "query", "ids", "vcard", "contacts", "messageType", "orMessageType2", "orMessageType3", "destination", "qrText", "timestampBegin", "timestampEnd", "instanceMsgId", "updateStr", "descr", "data", "instanceMessageId", "lastKnownSerial", "infoMsgId", "filePath", "url", "stickerPath", "reaction", "newText", "collection", "text", "file", "filename", "location", "quotedMessageId", "viewType", "dist_exports", "__export", "BaseTransport", "WebsocketTransport", "Emitter", "__name", "event", "callback", "ctx", "data", "listener", "args", "filtered", "BaseTransport", "Emitter", "__name", "_message", "message", "request", "response", "handler", "method", "params", "id", "resolve", "reject", "import_isomorphic_ws", "WebsocketTransport", "BaseTransport", "__name", "url", "options", "onmessage", "event", "message", "ReconnectingWebsocket", "error", "serialized", "Emitter", "resolveReady", "resolve", "WebSocket", "_event", "wait", "import_tiny_emitter", "BaseDeltaChat", "__name", "transport", "startEventLoop", "RawClient", "event", "account_id", "C", "parseThemeMetaData", "rawTheme", "meta_data_block", "regex", "meta", "last_result", "__name", "HIDDEN_THEME_PREFIX", "WebsocketTransport", "dist_exports", "logJsonrpcConnection", "BrowserTransport", "callCounterFunction", "__name", "message", "BrowserDeltachat", "BaseDeltaChat", "BrowserRuntime", "event", "_accountId", "_chatId", "_file", "_message_id", "_isContactRequest", "_subject", "_sender", "_receiveTime", "_content", "_instanceId", "_payload", "file", "isDefaultPicture", "result", "locale", "messagesEnglish", "untranslated", "localeMessages", "error1", "base_locale", "error2", "_locale", "key", "value", "address", "location", "id", "realPath", "theme_file_request", "data", "metadata", "parseThemeMetaData", "HIDDEN_THEME_PREFIX", "name", "content", "_fileName", "_sourcePath", "cb", "accountId", "chatId", "body", "title", "notificationIcon", "messageId", "icon", "url", "response", "blob", "resolve", "reject", "reader", "error", "notification", "notify", "request", "config", "_msgId", "_params", "path", "_name", "pathToSource", "filename", "clipboardItems", "clipboardItem", "type", "err", "text", "imgURL", "img", "blobPromise", "canvas", "ctx", "blob_path", "matches", "_sticker_path", "options", "extstring", "filter", "p", "c", "ext", "input", "uploads", "r", "results", "uploadedFiles", "rejectedPromise", "link", "setLogHandler", "getLogger", "RCConfigRequest", "RuntimeInfoRequest", "channel", "level", "stack_trace", "args", "anchor", "curLang", "anchorPath", "mediaType", "stream", "track"]
}
